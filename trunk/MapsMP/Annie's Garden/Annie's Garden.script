const
  TIME_TO_HOLD = 5*60*10; //5 minutes
  MAX_TIME_AWAY = 2*10; //2 seconds
  LOC_COUNT = 8; //Total number of locations on this map
var
  Owner: array[1..5] of Integer; //Current owner of each location
  TimeOwnerLeft: array[1..5] of Integer; //The time the owner left the location (stepping off location for a few seconds is allowed)
  WinningPlayer: Integer;
  TimeStartedWinning: Integer; //The time at which the team that owns enough locations started owning them
  GameEnded: Boolean; //Has somebody won the game yet?

//Returns list of player and his allies like this: '[$BBGGRR]Lewin[], [$BBGGRR]Krom[]'
function GetTeamMembers(aPlayer: Integer): AnsiString;
var I: Integer;
begin
  Result := '';
  for I:=0 to LOC_COUNT-1 do
    if States.PlayerEnabled(I) then
	  if (I = aPlayer) or States.PlayerAllianceCheck(aPlayer,I) then
	    Result := Result + '[$'+States.PlayerColorText(I)+']'+States.PlayerName(I)+'[], ';
  //Remove ', ' from the end
  if Result <> '' then
    Result := Copy(Result, 1, Length(Result)-2); //Remove two characters from the end
end;

//Processes the fact that aPlayer and his team are winning, returning something like: '3 locations are held by [$BBGGRR]Lewin[], [$BBGGRR]Krom[]!|Time until victory: 03:45'
function ProcessWinningPlayer(aPlayer, aLocsHeld: Integer): AnsiString;
var Time, Mins, Secs: Integer;
begin
	//If this is a different WinningPlayer from last time, reset the counter
	if WinningPlayer = -1 then //Was there a previous WinningPlayer?
	  TimeStartedWinning := States.GameTime
	else
	  //Was that previous WinningPlayer a different player and an enemy?
	  if (aPlayer <> WinningPlayer) and not States.PlayerAllianceCheck(WinningPlayer, aPlayer) then
		TimeStartedWinning := States.GameTime;

	//Now update the WinningPlayer
	WinningPlayer := aPlayer;

	//Calculate the time left before this team wins
	Time := (TimeStartedWinning + TIME_TO_HOLD) - States.GameTime;
	if (Time <= 0) and not GameEnded then
	begin
	  //Declare the owner and his team victorious. All other players will get set to defeated.
	  Actions.PlayerWin([aPlayer], True);
	  GameEnded := True;
	end;
	if GameEnded then
	  Time := 0; //Don't show negative time

	//Show the countdown
	Mins := Time div 600;
	Secs := (Time div 10) mod 60;
	Result := States.TextFormatted(8, [aLocsHeld, GetTeamMembers(aPlayer), Mins, Secs]);
end;

//Updates the status display which is overlaid on the screen
procedure ShowStatusDisplay;
var
  I, K: Integer;
  Text: AnsiString;
  LocsHeld: Integer;
  FoundWinningPlayer: Boolean;
begin
  Text := '';
  FoundWinningPlayer := False;
  //Firstly write out who owns each location
  for I := 1 to 5 do
    if Owner[I] = -1 then
      Text := Text + States.TextFormatted(6, [States.Text(I)]) + '|'
	else
      Text := Text + States.TextFormatted(7, [States.Text(I), States.PlayerColorText(Owner[I]), States.PlayerName(Owner[I])]) + '|';

  Text := Text + '|'; //Blank line

  //Now see if a team holds 3 locations
  for I := 1 to 5 do
    if Owner[I] <> -1 then
    begin
      LocsHeld := 1; //Ok, so this team owns 1 location so far
	  //Now lets see how many other locations they own
      for K := 1 to 5 do
	    if (I <> K)
	    and (Owner[K] <> -1) then
		  if (Owner[I] = Owner[K]) or States.PlayerAllianceCheck(Owner[I], Owner[K]) then
		    Inc(LocsHeld);

	  //See if they hold enough locations
	  if LocsHeld >= 3 then
	  begin
	    FoundWinningPlayer := True;
    	Text := Text + ProcessWinningPlayer(Owner[I], LocsHeld);
		Break; //No need to check further locations, only one team can hold 3 locations at once
	  end;
    end;
	
  if not FoundWinningPlayer then
    WinningPlayer := -1; //Nobody is winning

  //Now show the message we made to the players
  for I:=0 to LOC_COUNT-1 do
    Actions.SetOverlayText(I, Text);
end;

//Returns the owner of the unit currently on the specified location, or -1 if nobody is on it
function GetCurrentOwner(aX, aY:Integer): Integer;
var
  UnitOwner, X, Y: Integer;
  U: Integer;
begin
  Result := -1;
  //Check 3 by 3 square around the location
  for X := -1 to 1 do
    for Y := -1 to 1 do
	begin
      U := States.UnitAt(aX+X, aY+Y);
      if U <> -1 then
      begin
        UnitOwner := States.UnitOwner(U);
        //Owner = -1 means invalid, -2 means animals
        if (UnitOwner <> -1) and (UnitOwner <> -2) then
		begin
		  //If we haven't found anybody else on the location yet, this player is the owner for now
		  if Result = -1 then
            Result := UnitOwner
		  else
		    if (Result <> UnitOwner) and not States.PlayerAllianceCheck(Result, UnitOwner) then
			begin
			  //The location has more than one player on it (not allies), so nobody owns it
			  Result := -1;
			  Exit;
			end;
		end;
      end;
	end;
end;

//Updates the location ID which is at coordinates aX and aY
procedure UpdateLocation(ID, aX, aY: Integer);
var NewOwner: Integer;
begin
  NewOwner := GetCurrentOwner(aX, aY);
  //If the owner just left the location, we give him a moment to return (due to units pushing each other)
  if (NewOwner = -1) and (Owner[ID] <> -1) then
  begin
    if TimeOwnerLeft[ID] = -1 then
      TimeOwnerLeft[ID] := States.GameTime //Remember when they left the location (now)
    else
      if States.GameTime >= TimeOwnerLeft[ID]+MAX_TIME_AWAY then
        Owner[ID] := -1; //Owner has gone
  end
  else
  begin
    TimeOwnerLeft[ID] := -1;
    Owner[ID] := NewOwner;
  end;
end;

procedure UpdateLocations;
begin
  if GameEnded then Exit; //Don't process anything if the game is over
  UpdateLocation(1, 89,  94);  //Bridge
  UpdateLocation(2, 155, 97);  //Lookout
  UpdateLocation(3, 122, 119); //Center hill
  UpdateLocation(4, 84,  154); //Wall
  UpdateLocation(5, 161, 154); //Pillars
end;

//Initialise variables here
procedure OnMissionStart;
var I: Integer;
begin
  GameEnded := False;
  WinningPlayer := -1;
  for I := 1 to 5 do
  begin
    Owner[I] := -1;
    TimeOwnerLeft[I] := -1;
  end;
  ShowStatusDisplay; //So it is shown from the start, rather than appearing after 1 tick
end;

procedure OnTick;
begin
  UpdateLocations;
  ShowStatusDisplay;
end;