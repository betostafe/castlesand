////////////////////////////////////////////////////
////////////////////////////////////////////////////
////////////////////////////////////////////////////
///////**************************************///////
///////***************THE MAZE***************///////
///////**GAME MODE VERSION 4.4 (2014-07-01)**///////
///////**********SCRIPT VERSION 4.4**********///////
///////************AI VERSION 1.0************///////
///////*********BY ANDREUS  2013-2014********///////
///////**************************************///////
////////////////////////////////////////////////////
////////////////////////////////////////////////////
////////////////////////////////////////////////////
 


///LIBX FILE INDEXES STRUCTURE
///(NOTE: SOME INDEXES ARE NOT USED YET
///BUT I CAN ADD NEW TEXTS SO I RESERVED THEM):


///0..25:    Special messages and texts
///26..49:   Messages for players
///50..74:   Tasks
///75..99:   Additional tasks
///100..124: Unused (reserved by Remake)
///125..149: Achievements names
///150..174: Achievements conditions
///175..199: Rewards for achievements
///200..224: Rewards for points



//Types


type
  MissionRec = Record
    Time:                    Integer;                                     //Game time
    TimeLeft:                AnsiString;                                  //Timer shown in stats
    ReinforcementTime:       Integer;                                     //Reinforcements timer
    Ended:                   Boolean;                                     //True if game is ended (won/lost)
    TasksCompleted:          Boolean;                                     //True if tasks completed
    RandomTaskCompleted:     Boolean;                                     //True if random task completed
    RandomTaskID:            Integer;                                     //ID of random task
    Notification:            Boolean;                                     //True if players received a message about patrol
    Team:                    AnsiString;                                  //Players names
    FactTeamScore:           Integer;                                     //Fact score
    PossibleTeamScore:       Integer;                                     //Possible score = fact score - penalties
    Scores:                  AnsiString;                                  //Scores as a text shown in stats
    Statistic:               AnsiString;                                  //Game statistic
    Minutes:                 AnsiString;                                  //Minutes as a text shown in stats
    Seconds:                 AnsiString;                                  //Seconds as a text shown in stats
    TimerColor:              AnsiString;                                  //Timer color
    Reinforcement:           AnsiString;                                  //Message about reinforcements shown in stats
    Teleport:                AnsiString;                                  //Message about teleport shown in stats
    RandomTask:              AnsiString;                                  //Message about random task shown in stats
    RandomTaskMsg:           AnsiString;                                  //Message about random task sent to players
    AddTaskMsg:              AnsiString;                                  //Random task status
    AddTaskHeader:           AnsiString;                                  //Random task header shown in stats
    AddAchievementScore:     array[0..3] of array[0..19] of Boolean;      //Have the players got points for achievements
    TilesX:                  array[0..99] of Integer;                     //Secret tiles
    TilesY:                  array[0..99] of Integer;                     //Secret tiles
    FoundTiles:              Integer;                                     //Number of found tiles
    TilesChosen:             array[0..99] of Boolean;                     //True if this tile was chosen
    OutpostCaptureMsg:       Boolean;                                     //True if message about AI trying to take control over outposts shown
    TeleportMsg:             Boolean;                                     //True if players have found teleports and got a message
    TeamVictoryLogged:       Boolean;                                     //Option for debugging
  end;


type
  AIRec = Record
    Groups:                  array[0..121] of Integer;                    //Group IDs for defense
    PosX:                    array[0..121] of Integer;                    //Group positions for defense
    PosY:                    array[0..121] of Integer;                    //Group positions for defense
    Direction:               array[0..121] of Integer;                    //Group directions for defense
    Defense:                 array[0..32] of Boolean;                     //True if groups for defense alive
    DefenseRanged:           array[0..32] of Boolean;                     //True if Ranged groups for defense alive
    GroupToAttack:           array[0..32] of Integer;                     //Group IDs for attack
    ReinforceGroup:          array[0..3] of Integer;                      //Group IDs for reinforcement
    ReinforceX:              array[0..3] of Integer;                      //Group positions for reinforcement
    ReinforceY:              array[0..3] of Integer;                      //Group positions for reinforcement
    Patrol:                  array[0..3] of Integer;                      //Group IDs for patrols
    Pirates:                 array[0..1] of Integer;                      //Group IDs for Pirates groups
    LocChanger:              Integer;                                     //Number of patrol's movements from one position to another
    OutpostDefenders:        array[0..1] of Integer;                      //Outpost defence groups
  end;


type
  StrategicPosition = Record
    Time:                    Integer;                                     //Time to hold position
    Visited:                 Boolean;                                     //Does the player visit certain position
    Captured:                Boolean;                                     //Does the player capture certain position
    PointsGiven:             Boolean;                                     //Have the players got points for capturing
    Text:                    AnsiString;                                  //Status text
    SoundPlayed:             Boolean;                                     //True if sound was played
  end;


type
  RandomTask = Record
    NeededCount:             Integer;                                     //Needed count of smth to complete the task
    CurrentCount:            Integer;                                     //Current count of smth to complete the task
  end;


type
  MainTask = Record
    NeededCount:             Integer;                                     //Needed count of smth to complete the task
    CurrentCount:            Integer;                                     //Current count of smth to complete the task
    Text:                    AnsiString;                                  //Status text
  end;


type
  Bonus = Record
    Get:                     Boolean;                                     //Have the players got the bonus
    Stop:                    Boolean;                                     //True if effect of the bonus is ended
    GetMsg:                  Boolean;                                     //Players received a message
    Text:                    AnsiString;                                  //Text shown in stats
    Time:                    Integer;                                     //Time of bonus effect
  end;


type
  IndividualAchievement = Record
    FactCount:               array[0..3] of Integer;                      //Current count of smth to get an achievement
    NeededCount:             array[0..3] of Integer;                      //Needed count of smth to get an achievement
    Get:                     array[0..3] of Boolean;                      //Have the players got certain achievement
    GetBy:                   AnsiString;                                  //Player names
    Progress:                array[0..3] of AnsiString;                   //Progress of certain achievement
    VarietyIndex:            array[0..3] of array[0..8] of Integer;       //Variety index
  end;


type
  TeamAchievement = Record
    Get:                     Boolean;                                     //Have the players got certain achievements
    GetBy:                   AnsiString;                                  //Names of the players who got certain achievements
  end;


type
  Player = Record
    AchievementsText:        AnsiString;                                  //Text shown in achievements menu
    IsAlone:                 Boolean;                                     //True if certain player plays alone on his side (left or right)
    AloneReinforce:          array[0..3] of Integer;                      //Extra groups for alone players at start
    WatchTower:              Integer;                                     //Player's watchtower ID
    General:                 Integer;                                     //Player's general ID
    GeneralUnit:             Integer;                                     //General as unit
    SpawnX:                  array[0..2] of Integer;                      //Spawn points for bonus groups
    SpawnY:                  array[0..2] of Integer;                      //Spawn points for bonus groups
    AloneReinforceX:         array[0..3] of Integer;                      //Spawn points of extra groups for alone players
    AloneReinforceY:         array[0..3] of Integer;                      //Spawn points of extra groups for alone players
    Direction:               Integer;                                     //Spawn directions for bonus groups
    CurrentScore:            Integer;                                     //Current player's score
    FactScore:               Integer;                                     //Possible player's score = current score - penalties
    Got5TilesBonus:          Boolean;                                     //True if player received bonus for 5 secret tiles
    Got15TilesBonus:         Boolean;                                     //True if player received bonus for 15 secret tiles
    Got25TilesBonus:         Boolean;                                     //True if player received bonus for 25 secret tiles
    StartX:                  Integer;                                     //Start position to center the screen
    StartY:                  Integer;                                     //Start position to center the screen
    ShipX:                   Integer;                                     //Ship position to center the screen
    ShipY:                   Integer;                                     //Ship position to center the screen
  end;


type
  TeleportRec = Record
    UnitsCount:              array[0..3] of array[0..13] of Integer;      //Counts of teleported units
    DelayLeftSide:           Integer;                                     //Pause for teleports (left side)
    DelayRightSide:          Integer;                                     //Pause for teleports (right side)
    Counter:                 Integer;                                     //Teleports counter
    NewGroupLeft:            Integer;                                     //ID of teleported group (left side)
    NewGroupRight:           Integer;                                     //ID of teleported group (right side)
    GroupLeft:               Integer;                                     //ID of group to link (left side)
    GroupRight:              Integer;                                     //ID of group link (left side)
    TypeLeft:                Integer;                                     //Type of teleported unit (left side)
    TypeRight:               Integer;                                     //Type of teleported unit (right side)
    OwnerLeft:               Integer;                                     //Owner of teleported unit (left side)
    OwnerRight:              Integer;                                     //Owner of teleported unit (right side)
    UnitLeft:                Integer;                                     //ID of teleported unit (left side)
    UnitRight:               Integer;                                     //ID of teleported unit (right side)
    GroupTypeLeft:           Integer;                                     //Type of teleported group (left side)
    GroupTypeRight:          Integer;                                     //Type of teleported group (right side)
  end;


type
  SecretTileRec = Record
    X:                       Integer;                                     //Tile X coordinate
    Y:                       Integer;                                     //Tile Y coordinate
    Found:                   Boolean;                                     //True if players have found this tile
  end;


type
  DoubleCheckRec = Record                                                 //Sometimes buildings/units can be destroyed/killed by AI
    NoSoldiersLeft:          Boolean;                                     //Check if no enemy soldiers left
    NoCitizensLeft:          Boolean;                                     //Check if no enemy citizens left
    NoHousesLeft:            Boolean;                                     //Check if no enemy houses left
    NoStoresLeft:            Boolean;                                     //Check if no enemy storehouses left
    NoMilitaryLeft:          Boolean;                                     //Check if no enemy military buildings left
    NoCoalLeft:              Boolean;                                     //Check if no enemy coal mines left
    NoGoldLeft:              Boolean;                                     //Check if no enemy gold mines left
    NoIronLeft:              Boolean;                                     //Check if no enemy iron mines left
  end;



//Constants


const
  TELEPORTS_MAX                    = 100;   //Maximum number of teleports
  TELEPORTS_LINK_RADIUS            = 5;     //Radius to find closest group to link
  REINFORCEMENT_TIME               = 4500;  //We get reinforcements every 4500 ticks (7,5 minutes)
  PIRATE_REINF_TIME                = 2400;  //Reinforcements from pirates every 2400 ticks (4 minutes)
  GAME_TIME                        = 72000; //Maximum time to complete all tasks - 2 hours
  POSITION_HOLD_TIME               = 3000;  //Time to hold positions - 5 minutes
  POSITION_VISITED_TIME            = 2999;  //Reset time to hold position if the position is visited
  POSITION_VIS_CAPTURED_TIME       = 2998;  //Reset time to hold The Castle
  GET_RANGED_TIME                  = 27000; //Time when all players get ranged units as reinforcements
  AUTO_FEED_TIME                   = 9000;  //Autofeed every 9000 ticks (15 minutes)
  PATROLS_TIME                     = 600;   //Patrols will come to a new location every 600 ticks
  DEFENSE_CHECK_TIME               = 15;    //Check AI defense every 15 ticks
  DEFENSE_CHECK_TIME_RANGED        = 100;   //Check AI ranged defense every 100 ticks
  ADD_TASK_TIME                    = 300;   //Time when we get a random additional task
  REINF_FORMATION_TIME             = 1800;  //Check reinforcement formations every 3 minutes
  AI_EQUIP_START_TIME              = 15400; //AI starts to equip soldiers; we get a message
  POSITIONS_CHECK_TIME             = 10;    //Check every 10 ticks (for additional tasks)

  REINFORCEMENT_MIN                = 6;     //Minimum 6 soldiers per group
  REINFORCEMENT_ALONE_MIN          = 6;     //Minimum 6 soldiers per group for alone players initial reinforcement
  REINFORCEMENT_RANGED_MIN         = 9;     //Minimum 9 ranged per group for GiveRanged

  ADD_TASK_ARMY_COUNT              = 30;    //For additional tasks: Send to The Castle 30 ranged, mounted, melee or anti-horse units
  ADD_TASK_BARBS_COUNT             = 15;    //For additional task: Send to The Castle 15 barbarians
  ADD_TASK_LOST_SOLDIERS_COUNT     = 1600;  //For additional task: lose no more than 1600 soldiers

  ACHIEVEMENTS_RACE                = 48000; //Time limit to reach The Castle to get Race against the clock achievement
  ACHIEVEMENTS_MEAT_GRINDER        = 500;   //Number of soldiers you have to kill to get Meat Grinder achievement
  ACHIEVEMENTS_KILLER              = 50;    //Number of citizens you have to kill to get Killer achievement
  ACHIEVEMENTS_DEMOLISHER          = 20;    //Number of houses you have to destroy to get Demolisher achievement
  ACHIEVEMENTS_KNIGHT              = 30;    //Number of knights you should have to get Knight achievement
  ACHIEVEMENTS_HORSES              = 40;    //Number of mounted units you should have to get Hooooorses achievement
  ACHIEVEMENTS_SHOOTER             = 40;    //Number of ranged units you should have to get Shooter achievement
  ACHIEVEMENTS_INTO_SPEARS         = 40;    //Number of anti-horse units you should have to get Into Spears achievement
  ACHIEVEMENTS_INFANTRY            = 40;    //Number of melee units you should have to get Infantryman achievement
  ACHIEVEMENTS_BARBS_BOSS          = 20;    //Number of barbarians you should have to get Barbarian's Boss achievement
  ACHIEVEMENTS_VARIETY_TYPES       = 9;     //Number of soldiers types to get Variety achievement
  ACHIEVEMENTS_VARIETY_COUNT       = 10;    //Number of soldiers of each type you should have to get Variety achievement
  ACHIEVEMENTS_IRON                = 50;    //Number of iron armored units you should have to get Iron Man achievement
  ACHIEVEMENTS_LEATHER             = 50;    //Number of leather armored units you should have to get Leather Man achievement
  ACHIEVEMENTS_REBEL               = 40;    //Number of Town Hall units you should have to get Rebel achievement (NOTE: excluding Barbarians and Warriors)
  ACHIEVEMENTS_SPARTAN             = 300;   //Number of soldiers you should have at once to get 301st Spartan achievement
  ACHIEVEMENTS_2ND_CHANCE          = 10;    //If you have less than 10 soldiers you get 2nd chance achievement
  ACHIEVEMENTS_NOVICE              = 33;    //Reveal 33% of the map to get Novice Scout achievement
  ACHIEVEMENTS_PRO                 = 75;    //Reveal 75% of the map to get PRO Scout achievement

  ACHIEVEMENTS_NOVICE_SCOUTS       = 6;     //Give 6 Scouts for Novice Scout achievement
  ACHIEVEMENTS_PRO_SCOUTS          = 8;     //Give 8 Scouts for Novice Scout achievement
  ACHIEVEMENTS_COUNTER_SCOUTS      = 9;     //Give 9 Scouts for Novice Scout achievement
  ACHIEVEMENTS_RACE_SWORDS         = 6;     //Give 6 Sword Fighters for Race against the clock achievement
  ACHIEVEMENTS_RACE_BOWS           = 6;     //Give 6 Bowmen for Race against the clock achievement
  ACHIEVEMENTS_RACE_KNIGHTS        = 4;     //Give 4 Knights for Race against the clock achievement
  ACHIEVEMENTS_MEAT_KNIGHTS        = 6;     //Give 6 Knights for Meat Grinder achievement
  ACHIEVEMENTS_KILLER_BARBS        = 4;     //Give 4 Barbarians for Killer achievement
  ACHIEVEMENTS_DEMOLISHER_BOWS     = 6;     //Give 6 Bowmen for Demolisher achievement
  ACHIEVEMENTS_KNIGHT_KNIGHTS      = 9;     //Give 9 Knights for Knight achievement
  ACHIEVEMENTS_HORSES_KNIGHTS      = 4;     //Give 4 Knights for Hoooorses achievement
  ACHIEVEMENTS_HORSES_SCOUTS       = 4;     //Give 4 Scouts for Hoooorses achievement
  ACHIEVEMENTS_SHOOTER_CROSSBOWS   = 6;     //Give 6 Crossbowmen for Shooter achievement
  ACHIEVEMENTS_INTO_SPEARS_PIKES   = 6;     //Give 6 Pikemen for Into Spears achievement
  ACHIEVEMENTS_INFANTRYMAN_AXES    = 6;     //Give 6 Axe Fighters for Infantryman achievement
  ACHIEVEMENTS_INFANTRYMAN_SWORDS  = 4;     //Give 4 Sword Fighters for Infantryman achievement
  ACHIEVEMENTS_BARBS_BOSS_WARRIORS = 6;     //Give 6 Warriors for Barbarian's Boss achievement
  ACHIEVEMENTS_VARIETY_BOWS        = 6;     //Give 6 Bowmen for Variety achievement
  ACHIEVEMENTS_VARIETY_BARBS       = 6;     //Give 6 Barbarians for Variety achievement
  ACHIEVEMENTS_IRON_SWORDS         = 8;     //Give 6 Sword Fighters for Iron Man achievement
  ACHIEVEMENTS_LEATHER_AXES        = 8;     //Give 6 Axe Fighters for Leather Man achievement
  ACHIEVEMENTS_REBEL_REBELS        = 9;     //Give 9 Rebels for Rebel achievement
  ACHIEVEMENTS_SPARTAN_SWORDS      = 9;     //Give 9 Sword Fighters for 301st Spartan achievement
  ACHIEVEMENTS_SPARTAN_KNIGHTS     = 9;     //Give 9 Knights for 301st Spartan achievement
  ACHIEVEMENTS_2ND_CHANCE_AXES     = 9;     //Give 6 Axe Fighters for 2nd Chance achievement
  ACHIEVEMENTS_2ND_CHANCE_BOWS     = 9;     //Give 6 Bowmen for 2nd Chance achievement

  ACHIEVEMENTS_BALANCER            = 1.5;   //1.5x more difficult to get achievements if player is alone (because of more reinforce)

  ACHIEVEMENTS_2ND_CHANCE_SCORE    = -1000; //-1000 points for 2nd Chance achievement
  ACHIEVEMENTS_SCORE               = 250;   //Players get 250 points for achievement
  ACHIEVEMENTS_VARIETY_SCORE       = 1000;  //Too difficult to get it so players get +1000 points

  BUILDING_DEMOLISH_SCORE          = 20;    //Score for every destroyed building

  CAPTURE_OUTPOST_SCORE            = 100;   //Score for capturing the Outpost
  CAPTURE_CASTLE_SCORE             = 200;   //Score for capturing The Castle

  BONUS_EXTRA_POINTS               = 3500;  //Team score to get EXTRA bonus
  BONUS_TELEPORT_POINTS            = 5000;  //Team score to get TELEPORT bonus
  BONUS_INVERT_POINTS              = 7500;  //Team score to get INVERT bonus
  BONUS_FREEZE_POINTS              = 10000; //Team score to get FREEZE bonus
  BONUS_INVERT_TIME                = 1200;  //Invert time for 1200 ticks (2 minutes)
  BONUS_FREEZE_TIME                = 3000;  //Freeze time for 3000 ticks (5 minutes)
  BONUS_TELEPORT_TIME              = 300;   //Show message about bonus for 300 ticks (30 seconds)
  BONUS_EXTRA_TIME                 = 300;   //Show message about bonus for 300 ticks (30 seconds)
  BONUS_EXTRA_TROOP_COUNT          = 15;    //15 soldiers per group

  SECRET_TILES_BONUS_5             = 12;    //12 Axe Fighters for 5 secret tiles
  SECRET_TILES_BONUS_15            = 9;     //9 Knights for 15 secret tiles
  SECRET_TILES_BONUS_25            = 10;    //10 Warriors for 25 secret tiles
  SECRET_TILES_TIME                = 5;     //Choose tiles in 5 ticks after start
  TILES_CHECK_TIME                 = 5;     //Check tiles every 5 ticks
  DOUBLE_CHECK_TIME                = 20;    //To make sure we completed certain task

  DEBUG_MODE                       = False; //Option for debugging - should be FALSE!



//Global variables


var
  I, J, N: Integer;

  AI: AIRec;

  SecretTiles: array[0..24] of SecretTileRec;

  DoubleCheck: DoubleCheckRec;

  Players: array[0..3] of Player;

  MeatGrinder, Killer, Demolisher, Knight,
  Horses, IronMan, LeatherMan, BarbsBoss,
  IntoSpears, Rebel, Infantryman, Variety,
  Shooter, Spartan, SecondChance: IndividualAchievement;

  NoviceScout, ProScout, Counterintelligence,
  Pirate, Race: TeamAchievement;

  Mission: MissionRec;

  Teleport: TeleportRec;

  WesternOutpost, EasternOutpost, NorthernOutpost,
  SouthernOutpost, Castle: StrategicPosition;

  DestroyIron, DestroyGold, DestroyCoal,
  DestroyStores, DestroyMilitary, KillSoldiers: MainTask;

  DestroyAll, SaveTowers, KillAll, SaveGenerals,
  SendRanged, SendMelee, SendMounted, SendBarbs,
  SendAntihorse, LoseNoMore: RandomTask;

  ExtraGroup, ResetTeleport, TimeFreeze, TimeInvert: Bonus;


////////////////////////
//////SECRET TILES//////
////////////////////////


//Initialize secret tiles on the map


procedure InitializeTiles;
begin

  Mission.FoundTiles := 0;   //No tiles found yet

  Mission.TilesX[0]  := 1;
  Mission.TilesX[1]  := 159;
  Mission.TilesX[2]  := 2;
  Mission.TilesX[3]  := 158;
  Mission.TilesX[4]  := 22;
  Mission.TilesX[5]  := 137;
  Mission.TilesX[6]  := 25;
  Mission.TilesX[7]  := 133;
  Mission.TilesX[8]  := 40;
  Mission.TilesX[9]  := 124;
  Mission.TilesX[10] := 46;
  Mission.TilesX[11] := 113;
  Mission.TilesX[12] := 52;
  Mission.TilesX[13] := 109;
  Mission.TilesX[14] := 41;
  Mission.TilesX[15] := 119;
  Mission.TilesX[16] := 43;
  Mission.TilesX[17] := 34;
  Mission.TilesX[18] := 117;
  Mission.TilesX[19] := 128;
  Mission.TilesX[20] := 23;
  Mission.TilesX[21] := 134;
  Mission.TilesX[22] := 29;
  Mission.TilesX[23] := 134;
  Mission.TilesX[24] := 15;
  Mission.TilesX[25] := 146;
  Mission.TilesX[26] := 12;
  Mission.TilesX[27] := 148;
  Mission.TilesX[28] := 7;
  Mission.TilesX[29] := 152;
  Mission.TilesX[30] := 12;
  Mission.TilesX[31] := 149;
  Mission.TilesX[32] := 1;
  Mission.TilesX[33] := 159;
  Mission.TilesX[34] := 15;
  Mission.TilesX[35] := 145;
  Mission.TilesX[36] := 1;
  Mission.TilesX[37] := 159;
  Mission.TilesX[38] := 37;
  Mission.TilesX[39] := 123;
  Mission.TilesX[40] := 32;
  Mission.TilesX[41] := 126;
  Mission.TilesX[42] := 56;
  Mission.TilesX[43] := 101;
  Mission.TilesX[44] := 56;
  Mission.TilesX[45] := 102;
  Mission.TilesX[46] := 68;
  Mission.TilesX[47] := 92;
  Mission.TilesX[48] := 7;
  Mission.TilesX[49] := 153;
  Mission.TilesX[50] := 2;
  Mission.TilesX[51] := 158;
  Mission.TilesX[52] := 1;
  Mission.TilesX[53] := 159;
  Mission.TilesX[54] := 10;
  Mission.TilesX[55] := 148;
  Mission.TilesX[56] := 13;
  Mission.TilesX[57] := 147;
  Mission.TilesX[58] := 13;
  Mission.TilesX[59] := 146;
  Mission.TilesX[60] := 12;
  Mission.TilesX[61] := 147;
  Mission.TilesX[62] := 3;
  Mission.TilesX[63] := 153;
  Mission.TilesX[64] := 34;
  Mission.TilesX[65] := 126;
  Mission.TilesX[66] := 38;
  Mission.TilesX[67] := 122;
  Mission.TilesX[68] := 31;
  Mission.TilesX[69] := 127;
  Mission.TilesX[70] := 95;
  Mission.TilesX[71] := 80;
  Mission.TilesX[72] := 81;
  Mission.TilesX[73] := 78;
  Mission.TilesX[74] := 47;
  Mission.TilesX[75] := 112;
  Mission.TilesX[76] := 45;
  Mission.TilesX[77] := 115;
  Mission.TilesX[78] := 48;
  Mission.TilesX[79] := 114;
  Mission.TilesX[80] := 80;
  Mission.TilesX[81] := 64;
  Mission.TilesX[82] := 93;
  Mission.TilesX[83] := 80;
  Mission.TilesX[84] := 54;
  Mission.TilesX[85] := 70;
  Mission.TilesX[86] := 54;
  Mission.TilesX[87] := 54;
  Mission.TilesX[88] := 56;
  Mission.TilesX[89] := 90;
  Mission.TilesX[90] := 106;
  Mission.TilesX[91] := 106;
  Mission.TilesX[92] := 106;
  Mission.TilesX[93] := 101;
  Mission.TilesX[94] := 58;
  Mission.TilesX[95] := 60;
  Mission.TilesX[96] := 74;
  Mission.TilesX[97] := 85;
  Mission.TilesX[98] := 99;
  Mission.TilesX[99] := 80;

  Mission.TilesY[0]  := 155;
  Mission.TilesY[1]  := 155;
  Mission.TilesY[2]  := 147;
  Mission.TilesY[3]  := 147;
  Mission.TilesY[4]  := 148;
  Mission.TilesY[5]  := 148;
  Mission.TilesY[6]  := 142;
  Mission.TilesY[7]  := 142;
  Mission.TilesY[8]  := 146;
  Mission.TilesY[9]  := 146;
  Mission.TilesY[10] := 134;
  Mission.TilesY[11] := 134;
  Mission.TilesY[12] := 126;
  Mission.TilesY[13] := 126;
  Mission.TilesY[14] := 119;
  Mission.TilesY[15] := 120;
  Mission.TilesY[16] := 131;
  Mission.TilesY[17] := 134;
  Mission.TilesY[18] := 131;
  Mission.TilesY[19] := 132;
  Mission.TilesY[20] := 130;
  Mission.TilesY[21] := 130;
  Mission.TilesY[22] := 122;
  Mission.TilesY[23] := 122;
  Mission.TilesY[24] := 121;
  Mission.TilesY[25] := 122;
  Mission.TilesY[26] := 127;
  Mission.TilesY[27] := 127;
  Mission.TilesY[28] := 136;
  Mission.TilesY[29] := 136;
  Mission.TilesY[30] := 118;
  Mission.TilesY[31] := 118;
  Mission.TilesY[32] := 113;
  Mission.TilesY[33] := 113;
  Mission.TilesY[34] := 100;
  Mission.TilesY[35] := 99;
  Mission.TilesY[36] := 105;
  Mission.TilesY[37] := 106;
  Mission.TilesY[38] := 105;
  Mission.TilesY[39] := 105;
  Mission.TilesY[40] := 100;
  Mission.TilesY[41] := 100;
  Mission.TilesY[42] := 112;
  Mission.TilesY[43] := 114;
  Mission.TilesY[44] := 124;
  Mission.TilesY[45] := 129;
  Mission.TilesY[46] := 127;
  Mission.TilesY[47] := 128;
  Mission.TilesY[48] := 97;
  Mission.TilesY[49] := 96;
  Mission.TilesY[50] := 83;
  Mission.TilesY[51] := 83;
  Mission.TilesY[52] := 61;
  Mission.TilesY[53] := 61;
  Mission.TilesY[54] := 47;
  Mission.TilesY[55] := 48;
  Mission.TilesY[56] := 44;
  Mission.TilesY[57] := 44;
  Mission.TilesY[58] := 30;
  Mission.TilesY[59] := 30;
  Mission.TilesY[60] := 13;
  Mission.TilesY[61] := 13;
  Mission.TilesY[62] := 12;
  Mission.TilesY[63] := 11;
  Mission.TilesY[64] := 25;
  Mission.TilesY[65] := 25;
  Mission.TilesY[66] := 19;
  Mission.TilesY[67] := 20;
  Mission.TilesY[68] := 10;
  Mission.TilesY[69] := 10;
  Mission.TilesY[70] := 10;
  Mission.TilesY[71] := 2;
  Mission.TilesY[72] := 26;
  Mission.TilesY[73] := 49;
  Mission.TilesY[74] := 49;
  Mission.TilesY[75] := 46;
  Mission.TilesY[76] := 59;
  Mission.TilesY[77] := 59;
  Mission.TilesY[78] := 100;
  Mission.TilesY[79] := 101;
  Mission.TilesY[80] := 62;
  Mission.TilesY[81] := 67;
  Mission.TilesY[82] := 67;
  Mission.TilesY[83] := 80;
  Mission.TilesY[84] := 64;
  Mission.TilesY[85] := 65;
  Mission.TilesY[86] := 74;
  Mission.TilesY[87] := 84;
  Mission.TilesY[88] := 93;
  Mission.TilesY[89] := 65;
  Mission.TilesY[90] := 91;
  Mission.TilesY[91] := 81;
  Mission.TilesY[92] := 71;
  Mission.TilesY[93] := 101;
  Mission.TilesY[94] := 99;
  Mission.TilesY[95] := 104;
  Mission.TilesY[96] := 102;
  Mission.TilesY[97] := 102;
  Mission.TilesY[98] := 104;
  Mission.TilesY[99] := 102;
end;


//Get some tiles to find them


procedure GetTiles;
var
  Number: Integer;
begin
  for I := 0 to 24 do
  begin
    Number := States.KaMRandomI(100);
    if not Mission.TilesChosen[Number] then
    begin
      N := Number;
      SecretTiles[I].X := Mission.TilesX[N];
      SecretTiles[I].Y := Mission.TilesY[N];
      Mission.TilesChosen[N] := True;
    end;
  end;
end;


//Check tiles


procedure CheckTiles;
begin
  for I := 0 to 24 do
    if (States.GroupAt(SecretTiles[I].X, SecretTiles[I].Y) <> -1)
    and (States.GroupOwner(States.GroupAt(SecretTiles[I].X, SecretTiles[I].Y)) <= 3)
    and (States.GroupOwner(States.GroupAt(SecretTiles[I].X, SecretTiles[I].Y)) >= 0)
    and (not SecretTiles[I].Found) then
    begin
      Mission.FoundTiles := Mission.FoundTiles + 1;
      Actions.PlayWAV(-1, 'SECRETTILE', 1);
      SecretTiles[I].Found := True;
      Exit;
    end;
end;


//Check bonuses for found tiles


procedure CheckTilesBonus;
begin
  if Mission.FoundTiles >= 5 then
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        if not Players[I].Got5TilesBonus then
        begin
          Actions.GiveGroup(I, 15, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, SECRET_TILES_BONUS_5, 4);
          Actions.ShowMsgFormatted(I, '<$36> ' + '<$34> ' + '<$187>', [5, SECRET_TILES_BONUS_5]);
          Players[I].Got5TilesBonus := True;
          Exit;
        end;

  if Mission.FoundTiles >= 15 then
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        if not Players[I].Got15TilesBonus then
        begin
          Actions.GiveGroup(I, 22, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, SECRET_TILES_BONUS_15, 3);
          Actions.ShowMsgFormatted(I, '<$36> ' + '<$34> ' + '<$177>', [15, SECRET_TILES_BONUS_15]);
          Players[I].Got15TilesBonus := True;
          Exit;
        end;

  if Mission.FoundTiles >= 25 then
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        if not Players[I].Got25TilesBonus then
        begin
          Actions.GiveGroup(I, 26, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, SECRET_TILES_BONUS_25, 5);
          Actions.ShowMsgFormatted(I, '<$36> ' + '<$34> ' + '<$184>', [25, SECRET_TILES_BONUS_25]);
          Players[I].Got25TilesBonus := True;
          Exit;
        end;
end;


/////////////////////////////
//////SPECIAL FUNCTIONS//////
/////////////////////////////


//Check revealed fog


function AreaRevealed(aPlayer, aX, aY: Integer): Boolean;
begin
  if States.PlayerEnabled(aPlayer) then
    Result := States.FogRevealed(aPlayer, aX, aY)
  else
    Result := False;
end;


//Check units count


function UnitsCount(aPlayer, aType: Integer): Integer;
begin
  if States.PlayerEnabled(aPlayer) then
    Result := States.StatUnitTypeCount(aPlayer, aType)
  else
    Result := 0;
end;


//Army count


function ArmyCount(aPlayer: Integer): Integer;
begin
  if States.PlayerEnabled(aPlayer) then
    Result := States.StatArmyCount(aPlayer)
  else
    Result := 0;
end;


///////////////////////
//////AI DEFENSES//////
///////////////////////


//Initialize AI groups for defense


procedure InitializeAIGroups;
begin

//AI.Defense[0]

  AI.Groups[0]  := States.GroupAt(32, 142);
  AI.Groups[1]  := States.GroupAt(36, 139);
  AI.Groups[2]  := States.GroupAt(36, 143);
  AI.Groups[3]  := States.GroupAt(41, 141);
  AI.Groups[4]  := States.GroupAt(45, 140);

//AI.Defense[1]

  AI.Groups[5]  := States.GroupAt(127, 143);
  AI.Groups[6]  := States.GroupAt(123, 140);
  AI.Groups[7]  := States.GroupAt(123, 144);
  AI.Groups[8]  := States.GroupAt(118, 141);
  AI.Groups[9]  := States.GroupAt(114, 141);

//AI.Defense[2]

  AI.Groups[10] := States.GroupAt(48, 139);
  AI.Groups[11] := States.GroupAt(48, 136);
  AI.Groups[12] := States.GroupAt(51, 138);
  AI.Groups[13] := States.GroupAt(50, 132);

//AI.Defense[3]

  AI.Groups[14] := States.GroupAt(111, 140);
  AI.Groups[15] := States.GroupAt(111, 135);
  AI.Groups[16] := States.GroupAt(108, 139);
  AI.Groups[17] := States.GroupAt(108, 132);

//AI.Defense[4]

  AI.Groups[18] := States.GroupAt(48, 127);
  AI.Groups[19] := States.GroupAt(43, 124);
  AI.Groups[20] := States.GroupAt(38, 123);
  AI.Groups[21] := States.GroupAt(37, 126);

//AI.Defense[5]

  AI.Groups[22] := States.GroupAt(112, 127);
  AI.Groups[23] := States.GroupAt(116, 124);
  AI.Groups[24] := States.GroupAt(121, 123);
  AI.Groups[25] := States.GroupAt(122, 126);

//AI.Defense[6]

  AI.Groups[26] := States.GroupAt(33, 123);
  AI.Groups[27] := States.GroupAt(27, 125);
  AI.Groups[28] := States.GroupAt(21, 125);
  AI.Groups[29] := States.GroupAt(21, 131);
  AI.Groups[30] := States.GroupAt(16, 129);

//AI.Defense[7]

  AI.Groups[31] := States.GroupAt(128, 124);
  AI.Groups[32] := States.GroupAt(134, 126);
  AI.Groups[33] := States.GroupAt(139, 124);
  AI.Groups[34] := States.GroupAt(140, 130);
  AI.Groups[35] := States.GroupAt(143, 129);

//AI.Defense[8]

  AI.Groups[36] := States.GroupAt(21, 125);
  AI.Groups[37] := States.GroupAt(19, 119);
  AI.Groups[38] := States.GroupAt(21, 114);

//AI.Defense[9]

  AI.Groups[39] := States.GroupAt(139, 124);
  AI.Groups[40] := States.GroupAt(140, 119);
  AI.Groups[41] := States.GroupAt(138, 114);

//AI.Defense[10]

  AI.Groups[42] := States.GroupAt(15, 115);
  AI.Groups[43] := States.GroupAt(12, 115);
  AI.Groups[44] := States.GroupAt(12, 109);
  AI.Groups[45] := States.GroupAt(12, 106);

//AI.Defense[11]

  AI.Groups[46] := States.GroupAt(145, 115);
  AI.Groups[47] := States.GroupAt(148, 115);
  AI.Groups[48] := States.GroupAt(148, 109);
  AI.Groups[49] := States.GroupAt(146, 106);

//AI.Defense[12]

  AI.Groups[50] := States.GroupAt(23, 110);
  AI.Groups[51] := States.GroupAt(27, 106);
  AI.Groups[52] := States.GroupAt(32, 104);
  AI.Groups[53] := States.GroupAt(35, 108);

//AI.Defense[13]

  AI.Groups[54] := States.GroupAt(136, 111);
  AI.Groups[55] := States.GroupAt(134, 108);
  AI.Groups[56] := States.GroupAt(128, 102);
  AI.Groups[57] := States.GroupAt(126, 108);

//AI.Defense[14]

  AI.Groups[58] := States.GroupAt(40, 109);
  AI.Groups[59] := States.GroupAt(51, 115);
  AI.Groups[60] := States.GroupAt(57, 116);
  AI.Groups[61] := States.GroupAt(56, 121);
  AI.Groups[62] := States.GroupAt(60, 123);
  AI.Groups[63] := States.GroupAt(64, 123);
  AI.Groups[64] := States.GroupAt(63, 130);

//AI.Defense[15]

  AI.Groups[65] := States.GroupAt(119, 109);
  AI.Groups[66] := States.GroupAt(108, 115);
  AI.Groups[67] := States.GroupAt(103, 116);
  AI.Groups[68] := States.GroupAt(104, 121);
  AI.Groups[69] := States.GroupAt(97, 122);
  AI.Groups[70] := States.GroupAt(100, 124);
  AI.Groups[71] := States.GroupAt(97, 130);

//AI.Defense[16]

  AI.Groups[72] := States.GroupAt(39, 76);
  AI.Groups[73] := States.GroupAt(41, 71);

//AI.Defense[17]

  AI.Groups[74] := States.GroupAt(120, 76);
  AI.Groups[75] := States.GroupAt(118, 70);

//AI.Defense[18]

  AI.Groups[76] := States.GroupAt(36, 84);
  AI.Groups[77] := States.GroupAt(40, 88);
  AI.Groups[78] := States.GroupAt(48, 96);

//AI.Defense[19]

  AI.Groups[79] := States.GroupAt(124, 84);
  AI.Groups[80] := States.GroupAt(120, 88);
  AI.Groups[81] := States.GroupAt(113, 96);

//AI.Defense[20]

  AI.Groups[82] := States.GroupAt(22, 23);
  AI.Groups[83] := States.GroupAt(10, 17);

//AI.Defense[21]

  AI.Groups[84] := States.GroupAt(136, 24);
  AI.Groups[85] := States.GroupAt(149, 19);

//AI.Defense[22]

  AI.Groups[86] := States.GroupAt(4, 23);
  AI.Groups[87] := States.GroupAt(4, 19);
  AI.Groups[88] := States.GroupAt(5, 15);

//AI.Defense[23]

  AI.Groups[89] := States.GroupAt(156, 23);
  AI.Groups[90] := States.GroupAt(156, 19);
  AI.Groups[91] := States.GroupAt(155, 15);

//AI.Defense[24]

  AI.Groups[92] := States.GroupAt(49, 15);
  AI.Groups[93] := States.GroupAt(44, 12);

//AI.Defense[25]

  AI.Groups[94] := States.GroupAt(110, 14);
  AI.Groups[95] := States.GroupAt(115, 12);

//AI.Defense[26]

  AI.Groups[96] := States.GroupAt(80, 105);
  AI.Groups[97] := States.GroupAt(80, 108);

//AI.Defense[27]

  AI.Groups[98] := States.GroupAt(77, 115);
  AI.Groups[99] := States.GroupAt(80, 115);
  AI.Groups[100] := States.GroupAt(82, 115);
  AI.Groups[101] := States.GroupAt(80, 120);

//AI.Defense[28]

  AI.Groups[102] := States.GroupAt(80, 132);
  AI.Groups[103] := States.GroupAt(80, 136);
  AI.Groups[104] := States.GroupAt(80, 145);
  AI.Groups[105] := States.GroupAt(80, 147);
  AI.Groups[106] := States.GroupAt(71, 132);
  AI.Groups[107] := States.GroupAt(88, 132);

//AI.Defense[29]

  AI.Groups[108] := States.GroupAt(57, 48);
  AI.Groups[109] := States.GroupAt(59, 52);
  AI.Groups[110] := States.GroupAt(77, 57);
  AI.Groups[111] := States.GroupAt(76, 59);

//AI.Defense[30]

  AI.Groups[112] := States.GroupAt(104, 50);
  AI.Groups[113] := States.GroupAt(101, 53);
  AI.Groups[114] := States.GroupAt(84, 57);
  AI.Groups[115] := States.GroupAt(84, 59);

//AI.Defense[31]

  AI.Groups[116] := States.GroupAt(30, 55);
  AI.Groups[117] := States.GroupAt(16, 72);
  AI.Groups[118] := States.GroupAt(25, 79);

//AI.Defense[32]

  AI.Groups[119] := States.GroupAt(128, 54);
  AI.Groups[120] := States.GroupAt(144, 71);
  AI.Groups[121] := States.GroupAt(136, 79);

end;


//Positions and directions


procedure GetPositions;
begin
  for J := 0 to 121 do
  begin
    AI.PosX[J] := States.UnitPositionX(States.GroupMember(AI.Groups[J], 0));        //Position X at start of the game
    AI.PosY[J] := States.UnitPositionY(States.GroupMember(AI.Groups[J], 0));        //Position Y at start of the game
    AI.Direction[J] := States.UnitDirection(States.GroupMember(AI.Groups[J], 0));   //Direction at start of the game
  end;
end;


//Double Check


procedure ConditionsDoubleCheck;
begin
  DoubleCheck.NoSoldiersLeft := States.StatArmyCount(4) +  States.StatArmyCount(5) + States.StatArmyCount(6) + States.StatArmyCount(7) = 0;
  DoubleCheck.NoCitizensLeft := States.StatCitizenCount(7) = 0;
  DoubleCheck.NoHousesLeft   := Length(States.PlayerGetAllHouses(7)) = 0;
  DoubleCheck.NoMilitaryLeft := States.StatHouseMultipleTypesCount(7, [1, 2, 10, 13, 19, 20, 21]) = 0;
  DoubleCheck.NoStoresLeft   := States.StatHouseTypeCount(7, 11) = 0;
  DoubleCheck.NoCoalLeft     := States.StatHouseTypeCount(7, 6) = 0;
  DoubleCheck.NoGoldLeft     := States.StatHouseTypeCount(7, 5) = 0;
  DoubleCheck.NoIronLeft     := States.StatHouseTypeCount(7, 4) = 0;
end;


//Initialize variables


procedure OnMissionStart;
begin

//For debug

  Mission.TeamVictoryLogged := False;

//WatchTowers allowing to hide stats text and show achievements; Generals

  if States.PlayerEnabled(0) then
  begin
    Players[0].WatchTower := States.HouseAt(4, 147);
    Players[0].General := Actions.GiveGroup(0, 22, 19, 143, 2, 1, 1);
    Players[0].GeneralUnit := States.GroupMember(Players[0].General, 0);
    Actions.UnitHungerSet(Players[0].GeneralUnit, States.UnitMaxHunger);
  end;

  if States.PlayerEnabled(1) then
  begin
    Players[1].WatchTower := States.HouseAt(3, 155);
    Players[1].General := Actions.GiveGroup(1, 22, 3, 150, 2, 1, 1);
    Players[1].GeneralUnit := States.GroupMember(Players[1].General, 0);
    Actions.UnitHungerSet(Players[1].GeneralUnit, States.UnitMaxHunger);
  end;

  if States.PlayerEnabled(2) then
  begin
    Players[2].WatchTower := States.HouseAt(157, 147);
    Players[2].General := Actions.GiveGroup(2, 22, 139, 143, 6, 1, 1);
    Players[2].GeneralUnit := States.GroupMember(Players[2].General, 0);
    Actions.UnitHungerSet(Players[2].GeneralUnit, States.UnitMaxHunger);
  end;

  if States.PlayerEnabled(3) then
  begin
    Players[3].WatchTower := States.HouseAt(158, 156);
    Players[3].General := Actions.GiveGroup(3, 22, 157, 151, 6, 1, 1);
    Players[3].GeneralUnit := States.GroupMember(Players[3].General, 0);
    Actions.UnitHungerSet(Players[3].GeneralUnit, States.UnitMaxHunger);
  end;

//For teleport

  Teleport.GroupLeft              := -1;              //We did not teleport any groups from left to right side yet
  Teleport.GroupRight             := -1;              //We did not teleport any groups from right to left side yet
  Teleport.TypeLeft               := -1;              //We did not teleport any groups from left to right side yet
  Teleport.TypeRight              := -1;              //We did not teleport any groups from right to left side yet
  Teleport.GroupTypeLeft          := -1;              //We did not teleport any groups from left to right side yet
  Teleport.GroupTypeRight         := -1;              //We did not teleport any groups from right to left side yet
  Teleport.OwnerLeft              := -1;              //We did not teleport any groups from left to right side yet
  Teleport.OwnerRight             := -1;              //We did not teleport any groups from right to left side yet
  Teleport.UnitLeft               := -1;              //We did not teleport any groups from left to right side yet
  Teleport.UnitRight              := -1;              //We did not teleport any groups from right to left side yet
  Teleport.NewGroupLeft           := -1;              //We did not teleport any groups from left to right side yet
  Teleport.NewGroupRight          := -1;              //We did not teleport any groups from right to left side yet
  Teleport.DelayLeftSide          := 0;               //Will be used to set pause between teleports
  Teleport.DelayRightSide         := 0;               //Will be used to set pause between teleports
  Teleport.Counter                := TELEPORTS_MAX;   //Maximum number of teleports per game
  Mission.TeleportMsg             := False;           //Not shown yet

  for J := 0 to 13 do
  for I := 0 to 3 do
    Teleport.UnitsCount[I][J]     := 0;               //No teleports yet

//Reinforcements timer

  Mission.ReinforcementTime := REINFORCEMENT_TIME;

//AI defense

  for J := 0 to 32 do
  begin
    AI.Defense[J]       := True;  //Groups for defense aren't killed at start ;D
    AI.DefenseRanged[J] := True;  //Ranged groups for defense aren't killed at start ;D
    AI.GroupToAttack[J] := -1;    //No groups to attack yet
  end;

//AI groups

  InitializeAIGroups;

  AI.OutpostDefenders[0] := States.GroupAt(6, 113);
  AI.OutpostDefenders[1] := States.GroupAt(154, 113);

//Message about AI trying to take control over outposts

  Mission.OutpostCaptureMsg := False;

//Secret tiles

  InitializeTiles;

  for I := 0 to 24 do
    SecretTiles[I].Found := False;

  for I := 0 to 99 do
    Mission.TilesChosen[I] := False;

  for J := 0 to 3 do
  begin
    Players[J].Got5TilesBonus  := False;
    Players[J].Got15TilesBonus := False;
    Players[J].Got25TilesBonus := False;
  end;

//Check alliances to prevent stupid rehosts ;p

  for I := 0 to 3 do
  for J := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(J))
    and (I <> J) then
    begin
      Actions.PlayerAllianceChange(I, J, True, True);
      Actions.PlayerAllianceChange(J, I, True, True);
    end;

//Positions and directions for retreat

  GetPositions;

//Patrols

  AI.Patrol[0]          := States.GroupAt(81, 19);    //Knights in the forest
  AI.Patrol[1]          := States.GroupAt(81, 52);    //Scouts near the bridge
  AI.Patrol[2]          := States.GroupAt(42, 39);    //Knights to the left from walls
  AI.Patrol[3]          := States.GroupAt(118, 38);   //Knights to the right from walls
  AI.LocChanger         := -1;                        //Patrol location changer
  Mission.Notification  := False;                     //True if the Castle Patrol has spotted us

//Pirates

  AI.Pirates[0] := States.GroupAt(100, 12);
  AI.Pirates[1] := States.GroupAt(60, 11);

//True if the game ended

  Mission.Ended := False;

//True for one of strategic locations if this location is captured

  WesternOutpost.Captured         := False; //Western outpost
  EasternOutpost.Captured         := False; //Eastern outpost
  NorthernOutpost.Captured        := False; //Northern outpost
  SouthernOutpost.Captured        := False; //Southern outpost
  Castle.Captured                 := False; //Castle
  WesternOutpost.PointsGiven      := False; //No points given yet
  EasternOutpost.PointsGiven      := False; //No points given yet
  SouthernOutpost.PointsGiven     := False; //No points given yet
  NorthernOutpost.PointsGiven     := False; //No points given yet
  Castle.PointsGiven              := False; //No points given yet  

//True for one of strategic locations if this location is visited

  WesternOutpost.Visited     := False; //Western outpost
  EasternOutpost.Visited     := False; //Eastern outpost
  NorthernOutpost.Visited    := False; //Northern outpost
  SouthernOutpost.Visited    := False; //Southern outpost
  Castle.Visited             := False; //Castle

//True if sound was played

  WesternOutpost.SoundPlayed     := False;  //Western outpost
  EasternOutpost.SoundPlayed     := False;  //Eastern outpost
  NorthernOutpost.SoundPlayed    := False;  //Northern outpost
  SouthernOutpost.SoundPlayed    := False;  //Southern outpost
  Castle.SoundPlayed             := False;  //Castle

//True if all 11 tasks are completed

  Mission.TasksCompleted := False;

//True if additional task is completed

  Mission.RandomTaskCompleted := False;

//Additional task header

  Mission.AddTaskHeader := '||<$19>|';

//Number of lost soldiers

  LoseNoMore.CurrentCount := 0;

//Number of destroyed buildings and defeated soldiers or citizens on mission start

  DestroyIron.CurrentCount        := 0;     //Iron mines
  DestroyGold.CurrentCount        := 0;     //Gold mines
  DestroyCoal.CurrentCount        := 0;     //Coal mines
  DestroyStores.CurrentCount      := 0;     //Storehouses
  DestroyMilitary.CurrentCount    := 0;     //Military buildings and schools
  KillSoldiers.CurrentCount       := 0;     //Soldiers
  DestroyAll.CurrentCount         := 0;     //Enemy buildings
  KillAll.CurrentCount            := 0;     //Enemy citizens

//Number of soldiers in the castle

  SendMelee.CurrentCount     := 0;     //No melee units in the castle yet
  SendMounted.CurrentCount   := 0;     //No mounted units in the castle yet
  SendRanged.CurrentCount    := 0;     //No ranged units in the castle yet
  SendAntihorse.CurrentCount := 0;     //No antihorse units in the castle yet
  SendBarbs.CurrentCount     := 0;     //No barbarians in the castle yet

//Timers to hold the positions

  WesternOutpost.Time   := POSITION_HOLD_TIME;   //Western outpost
  EasternOutpost.Time   := POSITION_HOLD_TIME;   //Eastern outpost
  SouthernOutpost.Time  := POSITION_HOLD_TIME;   //Southern outpost
  NorthernOutpost.Time  := POSITION_HOLD_TIME;   //Northern outpost
  Castle.Time           := POSITION_HOLD_TIME;   //Castle

//General timer

  Mission.Time := GAME_TIME;

//Number of buildings/soldiers that we have to destroy/kill

  DestroyIron.NeededCount         := States.StatHouseTypeCount(7, 4);                                                  //Iron mines
  DestroyGold.NeededCount         := States.StatHouseTypeCount(7, 5);                                                  //Gold mines
  DestroyCoal.NeededCount         := States.StatHouseTypeCount(7, 3);                                                  //Coal mines
  DestroyStores.NeededCount       := States.StatHouseTypeCount(7, 11);                                                 //Storehouses
  KillSoldiers.NeededCount        := States.StatArmyCount(4)                                                           //Soldiers of player 4
  + States.StatArmyCount(5)                                                                                            //Soldiers of player 5
  + States.StatArmyCount(6)                                                                                            //Soldiers of player 6
  + States.StatArmyCount(7);                                                                                           //Soldiers of player 7
  DestroyMilitary.NeededCount     := States.StatHouseMultipleTypesCount(7, [1, 2, 10, 13, 19, 20, 21]);                //Iron smithies, weapon smithies and workshops, armor smithies and workshops and also barracks and schools
  DestroyAll.NeededCount          := Length(States.PlayerGetAllHouses(7));                                             //All enemy buildings
  SaveTowers.NeededCount          := States.StatHouseTypeCount(7, 17);                                                 //WatchTowers
  KillAll.NeededCount             := States.StatCitizenCount(7);                                                       //Citizens of player 7

//Spawn positions for bonus troops

  Players[0].SpawnX[0] := 7;
  Players[1].SpawnX[0] := 7;
  Players[2].SpawnX[0] := 153;
  Players[3].SpawnX[0] := 153;
  Players[0].SpawnY[0] := 146;
  Players[1].SpawnY[0] := 154;
  Players[2].SpawnY[0] := 146;
  Players[3].SpawnY[0] := 154;

  Players[0].SpawnX[1] := 9;
  Players[1].SpawnX[1] := 10;
  Players[2].SpawnX[1] := 150;
  Players[3].SpawnX[1] := 149;
  Players[0].SpawnY[1] := 142;
  Players[1].SpawnY[1] := 154;
  Players[2].SpawnY[1] := 142;
  Players[3].SpawnY[1] := 154;

  Players[0].SpawnX[2] := 8;
  Players[1].SpawnX[2] := 3;
  Players[2].SpawnX[2] := 149;
  Players[3].SpawnX[2] := 156;
  Players[0].SpawnY[2] := 150;
  Players[1].SpawnY[2] := 151;
  Players[2].SpawnY[2] := 147;
  Players[3].SpawnY[2] := 151;

//Start positions and ship positions to center the screen

  Players[0].StartX := 13;
  Players[1].StartX := 13;
  Players[2].StartX := 147;
  Players[3].StartX := 147;
  Players[0].StartY := 147;
  Players[1].StartY := 147;
  Players[2].StartY := 147;
  Players[3].StartY := 147;

  Players[0].ShipX := 60;
  Players[1].ShipX := 60;
  Players[2].ShipX := 100;
  Players[3].ShipX := 100;
  Players[0].ShipY := 10;
  Players[1].ShipY := 10;
  Players[2].ShipY := 10;
  Players[3].ShipY := 10;

//Spawn positions of extra groups for alone players

  Players[0].AloneReinforceX[0] := 12;
  Players[1].AloneReinforceX[0] := 17;
  Players[2].AloneReinforceX[0] := 147;
  Players[3].AloneReinforceX[0] := 141;
  Players[0].AloneReinforceY[0] := 147;
  Players[1].AloneReinforceY[0] := 145;
  Players[2].AloneReinforceY[0] := 147;
  Players[3].AloneReinforceY[0] := 145;

  Players[0].AloneReinforceX[1] := 10;
  Players[1].AloneReinforceX[1] := 17;
  Players[2].AloneReinforceX[1] := 150;
  Players[3].AloneReinforceX[1] := 142;
  Players[0].AloneReinforceY[1] := 152;
  Players[1].AloneReinforceY[1] := 152;
  Players[2].AloneReinforceY[1] := 150;
  Players[3].AloneReinforceY[1] := 151;

  Players[0].AloneReinforceX[2] := 6;
  Players[1].AloneReinforceX[2] := 13;
  Players[2].AloneReinforceX[2] := 152;
  Players[3].AloneReinforceX[2] := 145;
  Players[0].AloneReinforceY[2] := 151;
  Players[1].AloneReinforceY[2] := 155;
  Players[2].AloneReinforceY[2] := 154;
  Players[3].AloneReinforceY[2] := 154;

  Players[0].AloneReinforceX[3] := 8;
  Players[1].AloneReinforceX[3] := 21;
  Players[2].AloneReinforceX[3] := 154;
  Players[3].AloneReinforceX[3] := 138;
  Players[0].AloneReinforceY[3] := 145;
  Players[1].AloneReinforceY[3] := 150;
  Players[2].AloneReinforceY[3] := 150;
  Players[3].AloneReinforceY[3] := 149;

//Groups directions

  Players[0].Direction := 2;
  Players[1].Direction := 2;
  Players[2].Direction := 6;
  Players[3].Direction := 6;

//Timer color

  Mission.TimerColor := '00FF00';      //Lime

//Reinforcements balance: Alone players should get more soldiers to make mission possible to win even with 2-3 players.

  Players[0].IsAlone := (States.PlayerEnabled(0)) and (not States.PlayerEnabled(1));
  Players[1].IsAlone := (States.PlayerEnabled(1)) and (not States.PlayerEnabled(0));
  Players[2].IsAlone := (States.PlayerEnabled(2)) and (not States.PlayerEnabled(3));
  Players[3].IsAlone := (States.PlayerEnabled(3)) and (not States.PlayerEnabled(2));

//Achievements balance: Alone players get more soldiers, but it's more difficult to get achievements

  for I := 0 to 3 do
  begin
    if (States.PlayerEnabled(I))
    and (Players[I].IsAlone) then
    begin
      Knight.NeededCount[I]       := Round(ACHIEVEMENTS_KNIGHT * ACHIEVEMENTS_BALANCER);
      Horses.NeededCount[I]       := Round(ACHIEVEMENTS_HORSES * ACHIEVEMENTS_BALANCER);
      Shooter.NeededCount[I]      := Round(ACHIEVEMENTS_SHOOTER * ACHIEVEMENTS_BALANCER);
      IntoSpears.NeededCount[I]   := Round(ACHIEVEMENTS_INTO_SPEARS * ACHIEVEMENTS_BALANCER);
      Infantryman.NeededCount[I]  := Round(ACHIEVEMENTS_INFANTRY * ACHIEVEMENTS_BALANCER);
      BarbsBoss.NeededCount[I]    := Round(ACHIEVEMENTS_BARBS_BOSS * ACHIEVEMENTS_BALANCER);
      Variety.NeededCount[I]      := Round(ACHIEVEMENTS_VARIETY_COUNT * ACHIEVEMENTS_BALANCER);
      IronMan.NeededCount[I]      := Round(ACHIEVEMENTS_IRON * ACHIEVEMENTS_BALANCER);
      LeatherMan.NeededCount[I]   := Round(ACHIEVEMENTS_LEATHER * ACHIEVEMENTS_BALANCER);

//Extra groups at start for alone players

      Players[I].AloneReinforce[0] := Actions.GiveGroup(I, States.KaMRandomI(8) + 15, Players[I].AloneReinforceX[0], Players[I].AloneReinforceY[0], Players[I].Direction, States.KaMRandomI(3) + REINFORCEMENT_ALONE_MIN, 3 + States.KaMRandomI(2));
      Players[I].AloneReinforce[1] := Actions.GiveGroup(I, States.KaMRandomI(8) + 15, Players[I].AloneReinforceX[1], Players[I].AloneReinforceY[1], Players[I].Direction, States.KaMRandomI(3) + REINFORCEMENT_ALONE_MIN, 3 + States.KaMRandomI(2));
      Players[I].AloneReinforce[2] := Actions.GiveGroup(I, States.KaMRandomI(8) + 15, Players[I].AloneReinforceX[2], Players[I].AloneReinforceY[2], Players[I].Direction, States.KaMRandomI(3) + REINFORCEMENT_ALONE_MIN, 3 + States.KaMRandomI(2));
      Players[I].AloneReinforce[3] := Actions.GiveGroup(I, States.KaMRandomI(8) + 15, Players[I].AloneReinforceX[3], Players[I].AloneReinforceY[3], Players[I].Direction, States.KaMRandomI(3) + REINFORCEMENT_ALONE_MIN, 3 + States.KaMRandomI(2));

//Feed extra groups

      for J := 0 to 3 do
        Actions.GroupHungerSet(Players[I].AloneReinforce[J], States.UnitMaxHunger);

    end

//Not alone players don't get any extra group, have normal achievements conditions and will get normal reinforcement during the game

    else
      if (not Players[I].IsAlone) then
      begin
        Knight.NeededCount[I]      := ACHIEVEMENTS_KNIGHT;
        Horses.NeededCount[I]      := ACHIEVEMENTS_HORSES;
        Shooter.NeededCount[I]     := ACHIEVEMENTS_SHOOTER;
        IntoSpears.NeededCount[I]  := ACHIEVEMENTS_INTO_SPEARS;
        Infantryman.NeededCount[I] := ACHIEVEMENTS_INFANTRY;
        BarbsBoss.NeededCount[I]   := ACHIEVEMENTS_BARBS_BOSS;
        Variety.NeededCount[I]     := ACHIEVEMENTS_VARIETY_COUNT;
        IronMan.NeededCount[I]     := ACHIEVEMENTS_IRON;
        LeatherMan.NeededCount[I]  := ACHIEVEMENTS_LEATHER;
      end;
    end;

//Team Score

  Mission.FactTeamScore      := 0;     //No points yet
  Mission.PossibleTeamScore  := 0;     //No points yet

//Bonuses

  ExtraGroup.Get        := False;                //Team hasn't got this bonus yet
  ResetTeleport.Get     := False;                //Team hasn't got this bonus yet
  TimeInvert.Get        := False;                //Team hasn't got this bonus yet
  TimeFreeze.Get        := False;                //Team hasn't got this bonus yet
  TimeFreeze.Stop       := False;                //Freeze has not began yet - no need to stop
  TimeInvert.Stop       := False;                //Invert has not began yet - no need to stop
  TimeInvert.GetMsg     := False;                //Message is not shown yet
  TimeFreeze.GetMsg     := False;                //Message is not shown yet
  TimeFreeze.Time       := BONUS_FREEZE_TIME;    //Freeze time for 3000 ticks (5 minutes)
  TimeInvert.Time       := BONUS_INVERT_TIME;    //Invert time for 1200 ticks (2 minutes)
  ExtraGroup.Time       := BONUS_EXTRA_TIME;     //Show message about bonus for 300 ticks (30 seconds)
  ResetTeleport.Time    := BONUS_TELEPORT_TIME;  //Show message about bonus for 300 ticks (30 seconds)

//Achievements

  for I := 0 to 3 do
  for J := 0 to 8 do
    Variety.VarietyIndex[I][J] := 0;             //Variety indexes for each player and each type of soldiers

  for I := 0 to 3 do
  for J := 0 to 19 do
    Mission.AddAchievementScore[I][J] := True;   //True: players get + points for achievements

  NoviceScout.Get            := False; //Team hasn't got this achievement yet
  ProScout.Get               := False; //Team hasn't got this achievement yet
  Counterintelligence.Get    := False; //Team hasn't got this achievement yet
  Race.Get                   := False; //Team hasn't got this achievement yet
  Pirate.Get                 := False; //Team hasn't got this achievement yet
  MeatGrinder.GetBy          := '';    //Team hasn't got this achievement yet, no player names
  Killer.GetBy               := '';    //Team hasn't got this achievement yet, no player names
  Demolisher.GetBy           := '';    //Team hasn't got this achievement yet, no player names
  Knight.GetBy               := '';    //Team hasn't got this achievement yet, no player names
  IronMan.GetBy              := '';    //Team hasn't got this achievement yet, no player names
  BarbsBoss.GetBy            := '';    //Team hasn't got this achievement yet, no player names
  LeatherMan.GetBy           := '';    //Team hasn't got this achievement yet, no player names
  Variety.GetBy              := '';    //Team hasn't got this achievement yet, no player names
  Race.GetBy                 := '';    //Team hasn't got this achievement yet, no player names
  NoviceScout.GetBy          := '';    //Team hasn't got this achievement yet, no player names
  ProScout.GetBy             := '';    //Team hasn't got this achievement yet, no player names
  Pirate.GetBy               := '';    //Team hasn't got this achievement yet, no player names
  Counterintelligence.GetBy  := '';    //Team hasn't got this achievement yet, no player names
  Horses.GetBy               := '';    //Team hasn't got this achievement yet, no player names
  IntoSpears.GetBy           := '';    //Team hasn't got this achievement yet, no player names
  Shooter.GetBy              := '';    //Team hasn't got this achievement yet, no player names
  Infantryman.GetBy          := '';    //Team hasn't got this achievement yet, no player names
  Rebel.GetBy                := '';    //Team hasn't got this achievement yet, no player names
  Spartan.GetBy              := '';    //Team hasn't got this achievement yet, no player names
  SecondChance.GetBy         := '';    //Team hasn't got this achievement yet, no player names

  for I := 0 to 3 do
  begin
    MeatGrinder.Get[I]       := False; //No one got this achievement yet
    Killer.Get[I]            := False; //No one got this achievement yet
    Demolisher.Get[I]        := False; //No one got this achievement yet
    Knight.Get[I]            := False; //No one got this achievement yet
    BarbsBoss.Get[I]         := False; //No one got this achievement yet
    IronMan.Get[I]           := False; //No one got this achievement yet
    LeatherMan.Get[I]        := False; //No one got this achievement yet
    Variety.Get[I]           := False; //No one got this achievement yet
    Horses.Get[I]            := False; //No one got this achievement yet
    IntoSpears.Get[I]        := False; //No one got this achievement yet
    Shooter.Get[I]           := False; //No one got this achievement yet
    Infantryman.Get[I]       := False; //No one got this achievement yet
    Rebel.Get[I]             := False; //No one got this achievement yet
    Spartan.Get[I]           := False; //No one got this achievement yet
    SecondChance.Get[I]      := False; //No one got this achievement yet
    MeatGrinder.FactCount[I] := 0;     //No soldiers killed yet
    Killer.FactCount[I]      := 0;     //No citizens killed yet
    Demolisher.FactCount[I]  := 0;     //No houses destroyed yet
    Players[I].CurrentScore  := 0;     //Score at mission start is 0
    Players[I].FactScore     := 0;     //Score at mission start is 0

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      Mission.Team := Mission.Team + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]' + ', ';      //Player names
  end;

  Delete(Mission.Team, Length(Mission.Team) - 1, Length(Mission.Team));                                                //Delete last ',' so text will be: player1, player2, player3, player4
end;


///////////////////////
//////AI SETTINGS//////
///////////////////////


///Global Settings///

//Attacks

//For melee, cavalry and anti-horses


procedure Attack(GroupID1, GroupID2, GroupToAttackID, UnitID: Integer);
begin
  if UnitID <> -1 then
    if (States.UnitOwner(UnitID) < 4)
    and (States.UnitOwner(UnitID) <> - 1)
    and (States.UnitType(UnitID) <= 27)                              //Don't attack animals etc
    and (States.UnitType(UnitID) >= 14) then
    begin
      AI.GroupToAttack[GroupToAttackID] := States.UnitsGroup(UnitID);
      if AI.GroupToAttack[GroupToAttackID] > 0 then
      begin
        for J := GroupID1 to GroupID2 do
          if AI.Groups[J] <> 0 then
            if not (States.GroupDead(AI.Groups[J]))
            and (AI.Groups[J] <> -1) then
              if States.GroupType(AI.Groups[J]) <> 2 then            //For ranged we need longer delay between enemy choosing. Otherwise they behave crazy...
                Actions.GroupOrderAttackUnit(AI.Groups[J], UnitID);  //Repeat attacks until enemy troop died
      end;
    end;
end;


//For ranged


procedure AttackRanged(GroupID1, GroupID2, GroupToAttackID, UnitID: Integer);
begin
  if UnitID <> -1 then
    if (States.UnitOwner(UnitID) < 4)
    and (States.UnitOwner(UnitID) <> - 1)
    and (States.UnitType(UnitID) <= 27)                              //Don't attack animals etc
    and (States.UnitType(UnitID) >= 14) then
    begin
      AI.GroupToAttack[GroupToAttackID] := States.UnitsGroup(UnitID);
      if AI.GroupToAttack[GroupToAttackID] > 0 then
      begin
        for J := GroupID1 to GroupID2 do
          if AI.Groups[J] <> 0 then
            if not (States.GroupDead(AI.Groups[J]))
            and (AI.Groups[J] <> -1) then
              if States.GroupType(AI.Groups[J]) = 2 then             //For ranged we need longer delay between enemy choosing. Otherwise they behave crazy...
               Actions.GroupOrderAttackUnit(AI.Groups[J], UnitID);   //Repeat attacks until enemy troop died
      end;
    end;
end;


//Retreat

//For melee, cavalry and anti-horse


procedure Retreat(ID1, ID2, ID3: Integer);
begin
  if AI.GroupToAttack[ID3] <> 0 then
  begin
    if States.GroupDead(AI.GroupToAttack[ID3]) then
      for J := ID1 to ID2 do
        if AI.Groups[J] <> 0 then
          if not States.GroupDead(AI.Groups[J]) then
            if (States.UnitPositionX(States.GroupMember(AI.Groups[J], 0)) <> AI.PosX[J])
            or (States.UnitPositionY(States.GroupMember(AI.Groups[J], 0)) <> AI.PosY[J]) then
              if States.GroupType(AI.Groups[J]) <> 2 then                                          //For ranged we need longer delay between enemy choosing. Otherwise they behave crazy...
                Actions.GroupOrderWalk(AI.Groups[J], AI.PosX[J], AI.PosY[J], AI.Direction[J]);     //Go back to the positions if enemy troop is killed
  end;
end;


//For ranged


procedure RetreatRanged(ID1, ID2, ID3: Integer);
begin
  if AI.GroupToAttack[ID3] <> 0 then
  begin
    if States.GroupDead(AI.GroupToAttack[ID3]) then
      for J := ID1 to ID2 do
        if AI.Groups[J] <> 0 then
          if not States.GroupDead(AI.Groups[J]) then
            if (States.UnitPositionX(States.GroupMember(AI.Groups[J], 0)) <> AI.PosX[J])
            or (States.UnitPositionY(States.GroupMember(AI.Groups[J], 0)) <> AI.PosY[J]) then
              if States.GroupType(AI.Groups[J]) = 2 then                                           //For ranged we need longer delay between enemy choosing. Otherwise they behave crazy...
                Actions.GroupOrderWalk(AI.Groups[J], AI.PosX[J], AI.PosY[J], AI.Direction[J]);     //Go back to the positions if enemy troop is killed
  end;
end;


//Check troops for defense

//For melee, cavalry and anti-horse


procedure CheckDefense(AIGroupID1, AIGroupID2, AIGroupID3, AIGroupID4, AIDefenseID: Integer);
begin
  if (States.GroupMemberCount(AI.Groups[AIGroupID1])
  + States.GroupMemberCount(AI.Groups[AIGroupID2])
  + States.GroupMemberCount(AI.Groups[AIGroupID3])
  + States.GroupMemberCount(AI.Groups[AIGroupID4]) = 0) then
    AI.Defense[AIDefenseID] := False;                           //Groups for this defense don't exist anymore...
end;


//For ranged


procedure CheckDefenseRanged(AIGroupID1, AIGroupID2, AIGroupID3, AIGroupID4, AIDefenseID: Integer);
begin
  if (States.GroupMemberCount(AI.Groups[AIGroupID1])
  + States.GroupMemberCount(AI.Groups[AIGroupID2])
  + States.GroupMemberCount(AI.Groups[AIGroupID3])
  + States.GroupMemberCount(AI.Groups[AIGroupID4]) = 0) then
    AI.DefenseRanged[AIDefenseID] := False;                     //Ranged groups for this defense don't exist anymore...
end;


//Check outpost defense


function OutpostDefenseDead: Boolean;
begin
  Result := (States.GroupDead(AI.OutpostDefenders[0]) or (AI.OutpostDefenders[0] = -1))
  or (States.GroupDead(AI.OutpostDefenders[1]) or (AI.OutpostDefenders[1] = -1));
end;


///AI defense///

//For left bridge


procedure AIDefenseLeftBridge(aRanged: Boolean);
var
  XLB, YLB, ULB: Integer;
begin
  for XLB := 21 to 29 do
  for YLB := 139 to 145 do
  begin
    ULB := States.UnitAt(XLB, YLB);
    if (not aRanged) then
      Attack(0, 4, 0, ULB)
    else
      AttackRanged(0, 4, 0, ULB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(0, 3, 0, 3, 0);
    Retreat(0, 4, 0);
  end
  else
  begin
    CheckDefenseRanged(1, 2, 4, 1, 0);
    RetreatRanged(0, 4, 0);
  end;
end;


//For right bridge


procedure AIDefenseRightBridge(aRanged: Boolean);
var
  XRB, YRB, URB: Integer;
begin
  for XRB := 130 to 138 do
  for YRB := 139 to 145 do
  begin
    URB := States.UnitAt(XRB, YRB);
    if (not aRanged) then
      Attack(5, 9, 1, URB)
    else
      AttackRanged(5, 9, 1, URB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(5, 8, 5, 8, 1);
    Retreat(5, 9, 1);
  end
  else
  begin
    CheckDefenseRanged(6, 7, 9, 6, 1);
    RetreatRanged(5, 9, 1);
  end;
end;


//For Vagabonds near the left bridge


procedure AIDefenseLeftVagabond(aRanged: Boolean);
var
  XLV, YLV, ULV: Integer;
begin
  for XLV := 35 to 45 do
  for YLV := 137 to 147 do
  begin
    ULV := States.UnitAt(XLV, YLV);
    if (not aRanged) then
      Attack(10, 13, 2, ULV)
    else
      AttackRanged(10, 13, 2, ULV);
  end;

  if (not aRanged) then
  begin
    CheckDefense(10, 11, 10, 11, 2);
    Retreat(10, 13, 2);
  end
  else
  begin
    CheckDefenseRanged(12, 12, 13, 13, 2);
    RetreatRanged(10, 13, 2);
  end;
end;


//For Vagabonds near the right bridge


procedure AIDefenseRightVagabond(aRanged: Boolean);
var
  XRV, YRV, URV: Integer;
begin
  for XRV := 115 to 125 do
  for YRV := 137 to 147 do
  begin
    URV := States.UnitAt(XRV, YRV);
    if (not aRanged) then
      Attack(14, 17, 3, URV)
    else
      AttackRanged(14, 17, 3, URV);
  end;

  if (not aRanged) then
  begin
    CheckDefense(14, 15, 14, 15, 3);
    Retreat(14, 17, 3);
  end
  else
  begin
    CheckDefenseRanged(16, 17, 16, 17, 3);
    RetreatRanged(14, 17, 3);
  end;
end;


//For Scouts near the left bridge


procedure AIDefenseLeftScouts(aRanged: Boolean);
var
  XLS, YLS, ULS: Integer;
begin
  for XLS := 44 to 57 do
  for YLS := 126 to 140 do
  begin
    ULS := States.UnitAt(XLS, YLS);
    if (not aRanged) then
      Attack(18, 21, 4, ULS)
    else
      AttackRanged(18, 21, 4, ULS);
  end;

  if (not aRanged) then
  begin
    CheckDefense(18, 19, 19, 21, 4);
    Retreat(18, 21, 4);
  end
  else
  begin
    CheckDefenseRanged(20, 20, 20, 20, 4);
    RetreatRanged(18, 21, 4);
  end;
end;


//For Scouts near the right bridge


procedure AIDefenseRightScouts(aRanged: Boolean);
var
  XRS, YRS, URS: Integer;
begin
  for XRS := 102 to 116 do
  for YRS := 126 to 140 do
  begin
    URS := States.UnitAt(XRS, YRS);
    if (not aRanged) then
      Attack(22, 25, 5, URS)
    else
      AttackRanged(22, 25, 5, URS);
  end;

  if (not aRanged) then
  begin
    CheckDefense(22, 23, 23, 25, 5);
    Retreat(22, 25, 5);
  end
  else
  begin
    CheckDefenseRanged(24, 24, 24, 24, 5);
    RetreatRanged(22, 25, 5);
  end;
end;


//For Scouts in the gorge near the left bridge


procedure AIDefenseLeftScoutsGorge(aRanged: Boolean);
var
  XLSG, YLSG, ULSG: Integer;
begin
  for XLSG := 37 to 47 do
  for YLSG := 119 to 129 do
  begin
    ULSG := States.UnitAt(XLSG, YLSG);
    if (not aRanged) then
      Attack(26, 30, 6, ULSG)
    else
      AttackRanged(26, 30, 6, ULSG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(26, 27, 28, 29, 6);
    Retreat(26, 30, 6);
  end
  else
  begin
    CheckDefenseRanged(30, 30, 30, 30, 6);
    RetreatRanged(26, 30, 6);
  end;
end;


//For Scouts in the gorge near the right bridge


procedure AIDefenseRightScoutsGorge(aRanged: Boolean);
var
  XRSG, YRSG, URSG: Integer;
begin
  for XRSG := 116 to 126 do
  for YRSG := 118 to 128 do
  begin
    URSG := States.UnitAt(XRSG, YRSG);
    if (not aRanged) then
      Attack(31, 35, 7, URSG)
    else
      AttackRanged(31, 35, 7, URSG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(31, 32, 33, 34, 7);
    Retreat(31, 35, 7);
  end
  else
  begin
    CheckDefenseRanged(35, 35, 35, 35, 7);
    RetreatRanged(31, 35, 7);
  end;
end;


//For Axe Fighters near the Western Outpost


procedure AIDefenseWOAxes(aRanged: Boolean);
var
  XWOA, YWOA, UWOA: Integer;
begin
  for XWOA := 23 to 35 do
  for YWOA := 119 to 132 do
  begin
    UWOA := States.UnitAt(XWOA, YWOA);
    if (not aRanged) then
      Attack(36, 38, 8, UWOA)
    else
      AttackRanged(36, 38, 8, UWOA);
  end;

  if (not aRanged) then
  begin
    CheckDefense(36, 37, 37, 36, 8);
    Retreat(36, 38, 8);
  end
  else
  begin
    CheckDefenseRanged(38, 38, 38, 38, 8);
    RetreatRanged(36, 38, 8);
  end;
end;


//For Axe Fighters near the Eastern Outpost


procedure AIDefenseEOAxes(aRanged: Boolean);
var
  XEOA, YEOA, UEOA: Integer;
begin
  for XEOA := 125 to 137 do
  for YEOA := 118 to 132 do
  begin
    UEOA := States.UnitAt(XEOA, YEOA);
    if (not aRanged) then
      Attack(39, 41, 9, UEOA)
    else
      AttackRanged(39, 41, 9, UEOA);
  end;

  if (not aRanged) then
  begin
    CheckDefense(39, 40, 39, 40, 9);
    Retreat(39, 41, 9);
  end
  else
  begin
    CheckDefenseRanged(41, 41, 41, 41, 9);
    RetreatRanged(39, 41, 9);
  end;
end;


//For Warriors near the Western Outpost


procedure AIDefenseWOWarriors(aRanged: Boolean);
var
  XWOW, YWOW, UWOW: Integer;
begin
  for XWOW := 14 to 28 do
  for YWOW := 114 to 135 do
  begin
    UWOW := States.UnitAt(XWOW, YWOW);
    if (not aRanged) then
      Attack(42, 45, 10, UWOW)
    else
      AttackRanged(42, 45, 10, UWOW);
  end;

  if (not aRanged) then
  begin
    CheckDefense(42, 42, 44, 45, 10);
    Retreat(42, 45, 10);
  end
  else
  begin
    CheckDefenseRanged(43, 43, 43, 43, 10);
    RetreatRanged(42, 45, 10);
  end;
end;


//For Warriors near the Eastern Outpost


procedure AIDefenseEOWarriors(aRanged: Boolean);
var
  XEOW, YEOW, UEOW: Integer;
begin
  for XEOW := 133 to 150 do
  for YEOW := 114 to 135 do
  begin
    UEOW := States.UnitAt(XEOW, YEOW);
    if (not aRanged) then
      Attack(46, 49, 11, UEOW)
    else
      AttackRanged(46, 49, 11, UEOW);
  end;

  if (not aRanged) then
  begin
    CheckDefense(46, 46, 48, 49, 11);
    Retreat(46, 49, 11);
  end
  else
  begin
    CheckDefenseRanged(47, 47, 47, 47, 11);
    RetreatRanged(46, 49, 11);
  end;
end;


//For Pikemen near the Western Outpost


procedure AIDefenseWOPikemen(aRanged: Boolean);
var
  XWOP, YWOP, UWOP: Integer;
begin
  for XWOP := 11 to 31 do
  for YWOP := 112 to 130 do
  begin
    UWOP := States.UnitAt(XWOP, YWOP);
    if (not aRanged) then
      Attack(50, 53, 12, UWOP)
    else
      AttackRanged(50, 53, 12, UWOP);
  end;

  if (not aRanged) then
  begin
    CheckDefense(50, 50, 52, 53, 12);
    Retreat(50, 53, 12);
  end
  else
  begin
    CheckDefenseRanged(51, 51, 51, 51, 12);
    RetreatRanged(50, 53, 12);
  end;
end;


//For Pikemen near the Eastern Outpost


procedure AIDefenseEOPikemen(aRanged: Boolean);
var
  XEOP, YEOP, UEOP: Integer;
begin
  for XEOP := 126 to 146 do
  for YEOP := 112 to 130 do
  begin
    UEOP := States.UnitAt(XEOP, YEOP);
    if (not aRanged) then
      Attack(54, 57, 13, UEOP)
    else
      AttackRanged(54, 57, 13, UEOP);
  end;

  if (not aRanged) then
  begin
    CheckDefense(54, 54, 56, 57, 13);
    Retreat(54, 57, 13);
  end
  else
  begin
    CheckDefenseRanged(55, 55, 55, 55, 13);
    RetreatRanged(54, 57, 13);
  end;
end;


//For Bowmen in the gorge near the Western Outpost


procedure AIDefenseLeftBowmenGorge(aRanged: Boolean);
var
  XLBG, YLBG, ULBG: Integer;
begin
  for XLBG := 31 to 48 do
  for YLBG := 100 to 115 do
  begin
    ULBG := States.UnitAt(XLBG, YLBG);
    if (not aRanged) then
      Attack(58, 64, 14, ULBG)
    else
      AttackRanged(58, 64, 14, ULBG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(59, 62, 63, 64, 14);
    Retreat(58, 64, 14);
  end
  else
  begin
    CheckDefenseRanged(58, 60, 61, 60, 14);
    RetreatRanged(58, 64, 14);
  end;
end;


//For Bowmen in the gorge near the Eastern Outpost


procedure AIDefenseRightBowmenGorge(aRanged: Boolean);
var
  XRBG, YRBG, URBG: Integer;
begin
  for XRBG := 102 to 130 do
  for YRBG := 100 to 115 do
  begin
    URBG := States.UnitAt(XRBG, YRBG);
    if (not aRanged) then
      Attack(65, 71, 15, URBG)
    else
      AttackRanged(65, 71, 15, URBG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(66, 69, 70, 71, 15);
    Retreat(65, 71, 15);
  end
  else
  begin
    CheckDefenseRanged(65, 67, 68, 65, 15);
    RetreatRanged(65, 71, 15);
  end;
end;


//For Warriors in the gorge (left side)


procedure AIDefenseLeftWarriorsGorge;
var
  XLWG, YLWG, ULWG: Integer;
begin
  for XLWG := 22 to 38 do
  for YLWG := 74 to 84 do
  begin
    ULWG := States.UnitAt(XLWG, YLWG);
    Attack(72, 73, 16, ULWG);
  end;

  CheckDefense(72, 73, 72, 73, 16);
  Retreat(72, 73, 16);
end;


//For Warriors in the gorge (right side)


procedure AIDefenseRightWarriorsGorge;
var
  XRWG, YRWG, URWG: Integer;
begin
  for XRWG := 121 to 138 do
  for YRWG := 73 to 85 do
  begin
    URWG := States.UnitAt(XRWG, YRWG);
    Attack(74, 75, 17, URWG);
  end;

  CheckDefense(74, 75, 74, 75, 17);
  Retreat(74, 75, 17);
end;


//For Pikemen in the gorge (left side)


procedure AIDefenseLeftPikemenGorge(aRanged: Boolean);
var
  XLPG, YLPG, ULPG: Integer;
begin
  for XLPG := 22 to 38 do
  for YLPG := 74 to 84 do
  begin
    ULPG := States.UnitAt(XLPG, YLPG);
    if (not aRanged) then
      Attack(76, 78, 18, ULPG)
    else
      AttackRanged(76, 78, 18, ULPG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(76, 76, 78, 78, 18);
    Retreat(76, 78, 18);
  end
  else
  begin
    CheckDefenseRanged(77, 77, 77, 77, 18);
    RetreatRanged(76, 78, 18);
  end;
end;


//For Pikemen in the gorge (right side)


procedure AIDefenseRightPikemenGorge(aRanged: Boolean);
var
  XRPG, YRPG, URPG: Integer;
begin
  for XRPG := 121 to 138 do
  for YRPG := 73 to 85 do
  begin
    URPG := States.UnitAt(XRPG, YRPG);
    if (not aRanged) then
      Attack(79, 81, 19, URPG)
    else
      AttackRanged(79, 81, 19, URPG);
  end;

  if (not aRanged) then
  begin
    CheckDefense(79, 79, 81, 81, 19);
    Retreat(79, 81, 19);
  end
  else
  begin
    CheckDefenseRanged(80, 80, 80, 80, 19);
    RetreatRanged(79, 81, 19);
  end;
end;


//For Knights in the mining area (left side)


procedure AIDefenseLeftMiningAreaKnights(aRanged: Boolean);
var
  XLMK, YLMK, ULMK: Integer;
begin
  for XLMK := 6 to 24 do
  for YLMK := 30 to 45 do
  begin
    ULMK := States.UnitAt(XLMK, YLMK);
    if (not aRanged) then
      Attack(82, 83, 20, ULMK)
    else
      AttackRanged(82, 83, 20, ULMK);
  end;

  if (not aRanged) then
  begin
    CheckDefense(82, 82, 82, 82, 20);
    Retreat(82, 83, 20);
  end
  else
  begin
    CheckDefenseRanged(83, 83, 83, 83, 20);
    RetreatRanged(82, 83, 20);
  end;
end;


//For Knights in the mining area (right side)


procedure AIDefenseRightMiningAreaKnights(aRanged: Boolean);
var
  XRMK, YRMK, URMK: Integer;
begin
  for XRMK := 135 to 153 do
  for YRMK := 29 to 45 do
  begin
    URMK := States.UnitAt(XRMK, YRMK);
    if (not aRanged) then
      Attack(84, 85, 21, URMK)
    else
      AttackRanged(84, 85, 21, URMK);
  end;

  if (not aRanged) then
  begin
    CheckDefense(84, 84, 84, 84, 21);
    Retreat(84, 85, 21);
  end
  else
  begin
    CheckDefenseRanged(85, 85, 85, 85, 21);
    RetreatRanged(84, 85, 21);
  end;
end;


//For Barbarians in the mining area (left side)


procedure AIDefenseLeftMiningAreaBarbarians(aRanged: Boolean);
var
  XLMB, YLMB, ULMB: Integer;
begin
  for XLMB := 1 to 10 do
  for YLMB := 25 to 40 do
  begin
    ULMB := States.UnitAt(XLMB, YLMB);
    if (not aRanged) then
      Attack(86, 88, 22, ULMB)
    else
      AttackRanged(86, 88, 22, ULMB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(86, 88, 86, 88, 22);
    Retreat(86, 88, 22);
  end
  else
  begin
    CheckDefenseRanged(87, 87, 87, 87, 22);
    RetreatRanged(86, 88, 22);
  end;
end;


//For Barbarians in the mining area (right side)


procedure AIDefenseRightMiningAreaBarbarians(aRanged: Boolean);
var
  XRMB, YRMB, URMB: Integer;
begin
  for XRMB := 150 to 159 do
  for YRMB := 25 to 40 do
  begin
    URMB := States.UnitAt(XRMB, YRMB);
    if (not aRanged) then
      Attack(89, 91, 23, URMB)
    else
      AttackRanged(89, 91, 23, URMB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(89, 91, 89, 91, 23);
    Retreat(89, 91, 23);
  end
  else
  begin
    CheckDefenseRanged(90, 90, 90, 90, 23);
    RetreatRanged(89, 91, 23);
  end;
end;


//For Warriors in the mining area (left side)


procedure AIDefenseLeftMiningAreaWarriors;
var
  XLMW, YLMW, ULMW: Integer;
begin
  for XLMW := 45 to 65 do
  for YLMW := 15 to 30 do
  begin
    ULMW := States.UnitAt(XLMW, YLMW);
    Attack(92, 93, 24, ULMW);
  end;

  CheckDefense(92, 93, 92, 93, 24);
  Retreat(92, 93, 24);
end;


//For Warriors in the mining area (right side)


procedure AIDefenseRightMiningAreaWarriors;
var
  XRMW, YRMW, URMW: Integer;
begin
  for XRMW := 95 to 115 do
  for YRMW := 15 to 30 do
  begin
    URMW := States.UnitAt(XRMW, YRMW);
    Attack(94, 95, 25, URMW);
  end;

  CheckDefense(94, 95, 94, 95, 25);
  Retreat(94, 95, 25);
end;


//For Barbarians on the Castle Bridge


procedure AIDefenseCastleBarbarians(aRanged: Boolean);
var
  XCB, YCB, UCB: Integer;
begin
  for XCB := 65 to 95 do
  for YCB := 90 to 105 do
  begin
    UCB := States.UnitAt(XCB, YCB);
    if (not aRanged) then
      Attack(96, 97, 26, UCB)
    else
      AttackRanged(96, 97, 26, UCB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(96, 96, 96, 96, 26);
    Retreat(96, 97, 26);
  end
  else
  begin
    CheckDefenseRanged(97, 97, 97, 97, 26);
    RetreatRanged(96, 97, 26);
  end;
end;


//For Bowmen on the way to Southern Outpost


procedure AIDefenseSouthernBowmen(aRanged: Boolean);
var
  XSOB, YSOB, USOB: Integer;
begin
  for XSOB := 75 to 85 do
  for YSOB := 102 to 114 do
  begin
    USOB := States.UnitAt(XSOB, YSOB);
    if (not aRanged) then
      Attack(98, 101, 27, USOB)
    else
      AttackRanged(98, 101, 27, USOB);
  end;

  if (not aRanged) then
  begin
    CheckDefense(98, 100, 100, 101, 27);
    Retreat(98, 101, 27);
  end
  else
  begin
    CheckDefenseRanged(99, 99, 99, 99, 27);
    RetreatRanged(98, 101, 27);
  end;
end;


//For Knights on the way to Southern Outpost


procedure AIDefenseSouthernKnights(aRanged: Boolean);
var
  XSOK, YSOK, USOK: Integer;
begin
  for XSOK := 72 to 88 do
  for YSOK := 120 to 130 do
  begin
    USOK := States.UnitAt(XSOK, YSOK);
    if (not aRanged) then
      Attack(102, 107, 28, USOK)
    else
      AttackRanged(102, 107, 28, USOK);
  end;

  if (not aRanged) then
  begin
    CheckDefense(102, 104, 102, 104, 28);
    Retreat(102, 107, 28);
  end
  else
  begin
    CheckDefenseRanged(103, 105, 106, 107, 28);
    RetreatRanged(102, 107, 28);
  end;
end;


//For Swordmen in the Central Valley (left side)


procedure AIDefenseLeftSwordmen(aRanged: Boolean);
var
  XLCS, YLCS, ULCS: Integer;
begin
  for XLCS := 45 to 60 do
  for YLCS := 35 to 50 do
  begin
    ULCS := States.UnitAt(XLCS, YLCS);
    if (not aRanged) then
      Attack(108, 111, 29, ULCS)
    else
      AttackRanged(108, 111, 29, ULCS);
  end;

  if (not aRanged) then begin
    CheckDefense(108, 110, 108, 110, 29);
    Retreat(108, 111, 29);
  end
  else
  begin
    CheckDefenseRanged(109, 111, 111, 111, 29);
    RetreatRanged(108, 111, 29);
  end;
end;


//For Swordmen in the Central Valley (right side)


procedure AIDefenseRightSwordmen(aRanged: Boolean);
var
  XRCS, YRCS, URCS: Integer;
begin
  for XRCS := 100 to 115 do
  for YRCS := 35 to 50 do
  begin
    URCS := States.UnitAt(XRCS, YRCS);
    if (not aRanged) then
      Attack(112, 115, 30, URCS)
    else
      AttackRanged(112, 115, 30, URCS);
  end;

  if (not aRanged) then
  begin
    CheckDefense(112, 112, 114, 114, 30);
    Retreat(112, 115, 30);
  end
  else
  begin
    CheckDefenseRanged(113, 115, 113, 115, 30);
    RetreatRanged(112, 115, 30);
  end;
end;


//For Swordmen in the gorges (left side)


procedure AIDefenseLeftGorgesSwordmen;
var
  XLGS, YLGS, ULGS: Integer;
begin
  for XLGS := 1 to 15 do
  for YLGS := 80 to 100 do
  begin
    ULGS := States.UnitAt(XLGS, YLGS);
    Attack(116, 118, 31, ULGS);
  end;

  CheckDefense(116, 117, 118, 118, 31);
  Retreat(116, 118, 31);
end;


//For Swordmen in the gorges (right side)


procedure AIDefenseRightGorgesSwordmen;
var
  XRGS, YRGS, URGS: Integer;
begin
  for XRGS := 145 to 159 do
  for YRGS := 80 to 100 do
  begin
    URGS := States.UnitAt(XRGS, YRGS);
    Attack(119, 121, 32, URGS);
  end;

  CheckDefense(119, 120, 121, 119, 32);
  Retreat(119, 121, 32);
end;


//AI Defense


procedure GetAIDefense(aRanged: Boolean);
begin

  if ((AreaRevealed(0, 32, 142))
  or (AreaRevealed(1, 32, 142))
  or (AreaRevealed(2, 32, 142))
  or (AreaRevealed(3, 32, 142)))
  and (AI.Defense[0]) then
    AIDefenseLeftBridge(aRanged);

  if ((AreaRevealed(0, 127, 143))
  or (AreaRevealed(1, 127, 143))
  or (AreaRevealed(2, 127, 143))
  or (AreaRevealed(3, 127, 143)))
  and (AI.Defense[1]) then
    AIDefenseRightBridge(aRanged);

  if ((AreaRevealed(0, 48, 139))
  or (AreaRevealed(1, 48, 139))
  or (AreaRevealed(2, 48, 139))
  or (AreaRevealed(3, 48, 139)))
  and (AI.Defense[2]) then
    AIDefenseLeftVagabond(aRanged);

  if ((AreaRevealed(0, 111, 140))
  or (AreaRevealed(1, 111, 140))
  or (AreaRevealed(2, 111, 140))
  or (AreaRevealed(3, 111, 140)))
  and (AI.Defense[3]) then
    AIDefenseRightVagabond(aRanged);

  if ((AreaRevealed(0, 48, 128))
  or (AreaRevealed(1, 48, 128))
  or (AreaRevealed(2, 48, 128))
  or (AreaRevealed(3, 48, 128)))
  and (AI.Defense[4]) then
    AIDefenseLeftScouts(aRanged);

  if ((AreaRevealed(0, 111, 128))
  or (AreaRevealed(1, 111, 128))
  or (AreaRevealed(2, 111, 128))
  or (AreaRevealed(3, 111, 128)))
  and (AI.Defense[5]) then
    AIDefenseRightScouts(aRanged);

  if ((AreaRevealed(0, 34, 123))
  or (AreaRevealed(1, 34, 123))
  or (AreaRevealed(2, 34, 123))
  or (AreaRevealed(3, 34, 123)))
  and (AI.Defense[6]) then
    AIDefenseLeftScoutsGorge(aRanged);

  if ((AreaRevealed(0, 126, 123))
  or (AreaRevealed(1, 126, 123))
  or (AreaRevealed(2, 126, 123))
  or (AreaRevealed(3, 126, 123)))
  and (AI.Defense[7]) then
    AIDefenseRightScoutsGorge(aRanged);

  if ((AreaRevealed(0, 23, 124))
  or (AreaRevealed(1, 23, 124))
  or (AreaRevealed(2, 23, 124))
  or (AreaRevealed(3, 23, 124)))
  and (AI.Defense[8]) then
    AIDefenseWOAxes(aRanged);

  if ((AreaRevealed(0, 136, 123))
  or (AreaRevealed(1, 136, 123))
  or (AreaRevealed(2, 136, 123))
  or (AreaRevealed(3, 136, 123)))
  and (AI.Defense[9]) then
    AIDefenseEOAxes(aRanged);

  if ((AreaRevealed(0, 16, 116))
  or (AreaRevealed(1, 16, 116))
  or (AreaRevealed(2, 16, 116))
  or (AreaRevealed(3, 16, 116)))
  and (AI.Defense[10]) then
    AIDefenseWOWarriors(aRanged);

  if ((AreaRevealed(0, 144, 116))
  or (AreaRevealed(1, 144, 116))
  or (AreaRevealed(2, 144, 116))
  or (AreaRevealed(3, 144, 116)))
  and (AI.Defense[11]) then
    AIDefenseEOWarriors(aRanged);

  if ((AreaRevealed(0, 23, 111))
  or (AreaRevealed(1, 23, 111))
  or (AreaRevealed(2, 23, 111))
  or (AreaRevealed(3, 23, 111)))
  and (AI.Defense[12])
  and ((AI.Groups[42] <> 0) 
  and (States.GroupDead(AI.Groups[42]))
  or (AI.Groups[42] = -1)) then
    AIDefenseWOPikemen(aRanged);

  if ((AreaRevealed(0, 136, 112))
  or (AreaRevealed(1, 136, 112))
  or (AreaRevealed(2, 136, 112))
  or (AreaRevealed(3, 136, 112)))
  and (AI.Defense[13])
  and ((AI.Groups[46] <> 0) 
  and (States.GroupDead(AI.Groups[46]))
  or (AI.Groups[46] = -1)) then
    AIDefenseEOPikemen(aRanged);

  if ((AreaRevealed(0, 46, 109))
  or (AreaRevealed(1, 46, 109))
  or (AreaRevealed(2, 46, 109))
  or (AreaRevealed(3, 46, 109)))
  and (AI.Defense[14]) then
    AIDefenseLeftBowmenGorge(aRanged);

  if ((AreaRevealed(0, 114, 109))
  or (AreaRevealed(1, 114, 109))
  or (AreaRevealed(2, 114, 109))
  or (AreaRevealed(3, 114, 109)))
  and (AI.Defense[15]) then
    AIDefenseRightBowmenGorge(aRanged);

  if ((AreaRevealed(0, 37, 76))
  or (AreaRevealed(1, 37, 76))
  or (AreaRevealed(2, 37, 76))
  or (AreaRevealed(3, 37, 76)))
  and (AI.Defense[16]) then
    AIDefenseLeftWarriorsGorge;

  if ((AreaRevealed(0, 122, 76))
  or (AreaRevealed(1, 122, 76))
  or (AreaRevealed(2, 122, 76))
  or (AreaRevealed(3, 122, 76)))
  and (AI.Defense[17]) then
    AIDefenseRightWarriorsGorge;

  if ((AreaRevealed(0, 35, 82))
  or (AreaRevealed(1, 35, 82))
  or (AreaRevealed(2, 35, 82))
  or (AreaRevealed(3, 35, 82)))
  and (AI.Defense[18]) then
    AIDefenseLeftPikemenGorge(aRanged);

  if ((AreaRevealed(0, 126, 82))
  or (AreaRevealed(1, 126, 82))
  or (AreaRevealed(2, 126, 82))
  or (AreaRevealed(3, 126, 82)))
  and (AI.Defense[19]) then
    AIDefenseRightPikemenGorge(aRanged);

  if ((AreaRevealed(0, 20, 28))
  or (AreaRevealed(1, 20, 28))
  or (AreaRevealed(2, 20, 28))
  or (AreaRevealed(3, 20, 28)))
  and (AI.Defense[20]) then
    AIDefenseLeftMiningAreaKnights(aRanged);

  if ((AreaRevealed(0, 141, 28))
  or (AreaRevealed(1, 141, 28))
  or (AreaRevealed(2, 141, 28))
  or (AreaRevealed(3, 141, 28)))
  and (AI.Defense[21]) then
    AIDefenseRightMiningAreaKnights(aRanged);

  if ((AreaRevealed(0, 5, 25))
  or (AreaRevealed(1, 5, 25))
  or (AreaRevealed(2, 5, 25))
  or (AreaRevealed(3, 5, 25)))
  and (AI.Defense[22]) then
    AIDefenseLeftMiningAreaBarbarians(aRanged);

  if ((AreaRevealed(0, 155, 25))
  or (AreaRevealed(1, 155, 25))
  or (AreaRevealed(2, 155, 25))
  or (AreaRevealed(3, 155, 25)))
  and (AI.Defense[23]) then
    AIDefenseRightMiningAreaBarbarians(aRanged);

  if ((AreaRevealed(0, 51, 15))
  or (AreaRevealed(1, 51, 15))
  or (AreaRevealed(2, 51, 15))
  or (AreaRevealed(3, 51, 15)))
  and (AI.Defense[24]) then
    AIDefenseLeftMiningAreaWarriors;

  if ((AreaRevealed(0, 108, 14))
  or (AreaRevealed(1, 108, 14))
  or (AreaRevealed(2, 108, 14))
  or (AreaRevealed(3, 108, 14)))
  and (AI.Defense[25]) then
    AIDefenseRightMiningAreaWarriors;

  if ((AreaRevealed(0, 80, 104))
  or (AreaRevealed(1, 80, 104))
  or (AreaRevealed(2, 80, 104))
  or (AreaRevealed(3, 80, 104)))
  and (AI.Defense[26]) then
    AIDefenseCastleBarbarians(aRanged);

  if ((AreaRevealed(0, 80, 114))
  or (AreaRevealed(1, 80, 114))
  or (AreaRevealed(2, 80, 114))
  or (AreaRevealed(3, 80, 114)))
  and (AI.Defense[27]) then
    AIDefenseSouthernBowmen(aRanged);

  if ((AreaRevealed(0, 80, 130))
  or (AreaRevealed(1, 80, 130))
  or (AreaRevealed(2, 80, 130))
  or (AreaRevealed(3, 80, 130)))
  and (AI.Defense[28]) then
    AIDefenseSouthernKnights(aRanged);

  if ((AreaRevealed(0, 57, 46))
  or (AreaRevealed(1, 57, 46))
  or (AreaRevealed(2, 57, 46))
  or (AreaRevealed(3, 57, 46)))
  and (AI.Defense[29]) then
    AIDefenseLeftSwordmen(aRanged);

  if ((AreaRevealed(0, 104, 48))
  or (AreaRevealed(1, 104, 48))
  or (AreaRevealed(2, 104, 48))
  or (AreaRevealed(3, 104, 48)))
  and (AI.Defense[30]) then
    AIDefenseRightSwordmen(aRanged);

  if ((AreaRevealed(0, 5, 80))
  or (AreaRevealed(1, 5, 80))
  or (AreaRevealed(2, 5, 80))
  or (AreaRevealed(3, 5, 80)))
  and (AI.Defense[31]) then
    AIDefenseLeftGorgesSwordmen;

  if ((AreaRevealed(0, 155, 80))
  or (AreaRevealed(1, 155, 80))
  or (AreaRevealed(2, 155, 80))
  or (AreaRevealed(3, 155, 80)))
  and (AI.Defense[32]) then
    AIDefenseRightGorgesSwordmen;

end;


//Get types of soldiers that will attack us if we hold the position


function GetSoldiersType: Integer;
begin
  case States.KaMRandomI(5) of
    0: Result := 16;    //Sword fighters
    1: Result := 20;    //Pikemen
    2: Result := 22;    //Knights
    3: Result := 23;    //Barbarians
    4: Result := 26;    //Warriors
  end;
end;


//Now get these random attacks


procedure GetRandomAttack;
var 
  AGW, AGE, AGS1, AGS2, AGN1, AGN2, AGC1, AGC2: Integer;
begin
  if (WesternOutpost.Time = 1820)
  or (WesternOutpost.Time = 760) then
  begin
    AGW := Actions.GiveGroup(4, GetSoldiersType, 9, 106, 2, 12, 3);
    Actions.GroupOrderWalk(AGW, 6, 113, 2);
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 12;
  end;

 if AGW <> 0 then
   if (not States.GroupDead(AGW))
   and (AGW <> -1) then
     Actions.GroupOrderWalk(AGW, 6, 113, 2);

  if (EasternOutpost.Time = 1970)
  or (EasternOutpost.Time = 590) then
  begin
    AGE := Actions.GiveGroup(4, GetSoldiersType, 151, 106, 6, 12, 3);
    Actions.GroupOrderWalk(AGE, 154, 113, 6);
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 12;
  end;

  if AGE <> 0 then
    if (not States.GroupDead(AGE))
    and (AGE <> -1) then
      Actions.GroupOrderWalk(AGE, 154, 113, 6);

  if (SouthernOutpost.Time = 1710)
  or (SouthernOutpost.Time = 1220)
  or (SouthernOutpost.Time = 910)
  or (SouthernOutpost.Time = 650) then
  begin
    AGS1 := Actions.GiveGroup(4, GetSoldiersType, 72, 152, 0, 15, 3);
    Actions.GroupOrderWalk(AGS1, 80, 153, 0);
    AGS2 := Actions.GiveGroup(4, GetSoldiersType, 88, 152, 0, 15, 3);
    Actions.GroupOrderWalk(AGS2, 80, 153, 0);
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 30;
  end;

  if AGS1 <> 0 then
    if (not States.GroupDead(AGS1))
    and (AGS1 <> -1) then
      Actions.GroupOrderWalk(AGS1, 80, 153, 0);

  if AGS2 <> 0 then
    if (not States.GroupDead(AGS2))
    and (AGS2 <> -1) then
      Actions.GroupOrderWalk(AGS2, 80, 153, 0);

  if (NorthernOutpost.Time = 2550)
  or (NorthernOutpost.Time = 1440)
  or (NorthernOutpost.Time = 880) then
  begin
    AGN1 := Actions.GiveGroup(4, GetSoldiersType, 97, 21, 6, 18, 6);
    Actions.GroupOrderWalk(AGN1, 80, 7, 4);
    AGN2 := Actions.GiveGroup(4, GetSoldiersType, 64, 20, 2, 18, 6);
    Actions.GroupOrderWalk(AGN2, 80, 7, 4);
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 36;
  end;

  if AGN1 <> 0 then
    if (not States.GroupDead(AGN1))
    and (AGN1 <> -1) then
      Actions.GroupOrderWalk(AGN1, 80, 7, 4);

  if AGN2 <> 0 then
    if (not States.GroupDead(AGN2))
    and (AGN2 <> -1) then
      Actions.GroupOrderWalk(AGN2, 80, 7, 4);

  if (Castle.Time = 2330)
  or (Castle.Time = 1200)
  or (Castle.Time = 1150)
  or (Castle.Time = 520)
  or (Castle.Time = 510) then
  begin
    AGC1 := Actions.GiveGroup(4, GetSoldiersType, 60, 94, 0, 25, 5);
    Actions.GroupOrderWalk(AGC1, 66, 87, 4);
    AGC2 := Actions.GiveGroup(4, GetSoldiersType, 98, 95, 0, 25, 5);
    Actions.GroupOrderWalk(AGC2, 66, 87, 4);
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 50;
  end;

  if AGC1 <> 0 then
    if (not States.GroupDead(AGC1))
    and (AGC1 <> -1) then
      Actions.GroupOrderWalk(AGC1, 66, 87, 4);

  if AGC2 <> 0 then
    if (not States.GroupDead(AGC2))
    and (AGC2 <> -1) then
      Actions.GroupOrderWalk(AGC2, 66, 87, 4);

 end;


//Patrols


procedure GetPatrol;
begin
  AI.LocChanger := AI.LocChanger + 1;
  case AI.LocChanger mod 4 of

    0: begin
         if (not States.GroupDead(AI.Patrol[0]))
         and (AI.Patrol[0] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[0], 108, 40, 1);

         if (not States.GroupDead(AI.Patrol[1]))
         and (AI.Patrol[1] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[1], 52, 41, 7);

         if (not States.GroupDead(AI.Patrol[2]))
         and (AI.Patrol[2] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[2], 20, 32, 4);

         if (not States.GroupDead(AI.Patrol[3]))
         and (AI.Patrol[3] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[3], 138, 33, 4);
       end;

    1: begin
         if (not States.GroupDead(AI.Patrol[0]))
         and (AI.Patrol[0] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[0], 81, 52, 4);

         if (not States.GroupDead(AI.Patrol[1]))
         and (AI.Patrol[1] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[1], 81, 19, 4);

         if (not States.GroupDead(AI.Patrol[2]))
         and (AI.Patrol[2] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[2], 3, 42, 4);

         if (not States.GroupDead(AI.Patrol[3]))
         and (AI.Patrol[3] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[3], 157, 42, 4);
       end;

    2: begin
         if (not States.GroupDead(AI.Patrol[0]))
         and (AI.Patrol[0] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[0], 52, 41, 7);

         if (not States.GroupDead(AI.Patrol[1]))
         and (AI.Patrol[1] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[1], 108, 40, 1);

         if (not States.GroupDead(AI.Patrol[2]))
         and (AI.Patrol[2] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[2], 24, 44, 5);

         if (not States.GroupDead(AI.Patrol[3]))
         and (AI.Patrol[3] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[3], 135, 44, 3);
       end;

    3: begin
         if (not States.GroupDead(AI.Patrol[0]))
         and (AI.Patrol[0] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[0], 81, 19, 4);

         if (not States.GroupDead(AI.Patrol[1]))
         and (AI.Patrol[1] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[1], 81, 52, 4);

         if (not States.GroupDead(AI.Patrol[2]))
         and (AI.Patrol[2] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[2], 42, 39, 6);

         if (not States.GroupDead(AI.Patrol[3]))
         and (AI.Patrol[3] <> -1) then
           Actions.GroupOrderWalk(AI.Patrol[3], 118, 38, 2);
       end;
  end;
end;


//Check if the patrol has spotted us and send reinforcements for The Castle


procedure CheckSpotted;
begin
  if ((States.GroupDead(AI.Patrol[2]))
  or (States.GroupDead(AI.Patrol[3])))
  and not (Mission.Notification) then
  begin
    Actions.ShowMsg(-1, '<$28>');
    Actions.PlayWAVFadeMusic(-1, 'CASTLE', 0.5);
    AI.ReinforceGroup[0] := Actions.GiveGroup(4, GetSoldiersType, 76, 61, 0, 14, 7);
    AI.ReinforceGroup[1] := Actions.GiveGroup(4, GetSoldiersType, 84, 61, 0, 16, 8);
    AI.ReinforceGroup[2] := Actions.GiveGroup(4, GetSoldiersType, 76, 63, 0, 14, 7);
    AI.ReinforceGroup[3] := Actions.GiveGroup(4, GetSoldiersType, 84, 63, 0, 16, 8);
    AI.ReinforceX[0] := 76;
    AI.ReinforceX[1] := 84;
    AI.ReinforceX[2] := 76;
    AI.ReinforceX[3] := 84;
    AI.ReinforceY[0] := 61;
    AI.ReinforceY[1] := 61;
    AI.ReinforceY[2] := 63;
    AI.ReinforceY[3] := 63;
    Actions.GiveGroup(7, 22, 80, 111, 0, 9, 3);
    Actions.GiveGroup(7, 20, 75, 120, 0, 9, 3);
    Actions.GiveGroup(7, 16, 84, 120, 0, 9, 3);
    Actions.GiveGroup(7, 20, 77, 124, 0, 9, 3);
    Actions.GiveGroup(7, 22, 82, 124, 0, 9, 3);
    Actions.GiveGroup(7, 20, 77, 127, 0, 9, 3);
    Actions.GiveGroup(7, 16, 81, 127, 0, 9, 3);
    Actions.GiveGroup(7, 16, 77, 136, 0, 9, 3);
    Actions.GiveGroup(7, 18, 83, 136, 0, 9, 3);
    Actions.GiveGroup(7, 22, 77, 139, 0, 9, 3);
    Actions.GiveGroup(7, 20, 83, 139, 0, 9, 3);
    Actions.GiveGroup(7, 16, 80, 139, 0, 9, 3);
    Actions.GiveGroup(7, 20, 77, 142, 0, 9, 3);
    Actions.GiveGroup(7, 22, 80, 142, 0, 9, 3);
    Actions.GiveGroup(7, 16, 83, 142, 0, 9, 3);
    Actions.GiveGroup(7, 16, 72, 149, 0, 9, 3);
    Actions.GiveGroup(7, 20, 89, 149, 0, 9, 3);
    Actions.GiveGroup(7, 22, 100, 70, 0, 9, 3);
    Actions.GiveGroup(7, 22, 46, 60, 4, 25, 5);
    Actions.GiveGroup(7, 22, 115, 60, 4, 25, 5);
    Actions.GiveGroup(5, 16, 57, 21, 6, 15, 5);
    Actions.GiveGroup(5, 20, 57, 26, 6, 15, 5);
    Actions.GiveGroup(5, 16, 60, 21, 6, 15, 5);
    Actions.GiveGroup(5, 22, 60, 26, 6, 15, 5);
    Actions.GiveGroup(6, 16, 104, 21, 2, 15, 5);
    Actions.GiveGroup(6, 20, 104, 26, 2, 15, 5);
    Actions.GiveGroup(6, 16, 107, 21, 2, 15, 5);
    Actions.GiveGroup(6, 22, 107, 26, 2, 15, 5);
    AI.Groups[0] := Actions.GiveGroup(4, 22, 7, 107, 4, 15, 5);
    AI.Groups[5] := Actions.GiveGroup(4, 22, 153, 107, 4, 15, 5);
    AI.Defense[0] := True;
    AI.Defense[1] := True;
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 422;
    Mission.Notification := True;
    Exit;
  end;
end;


//Report about equipment start


procedure AIEquipReport;
begin
  Actions.ShowMsgGoTo(-1, 66, 87, '<$27>');
  Actions.PlayWAVFadeMusic(-1, 'CASTLE', 0.5);
  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      Actions.FogRevealCircle(I, 66, 87, 3);
end;


//Save Order and Formation for reinforcements


procedure SaveFormation;
begin
  for N := 0 to 3 do
    if (not States.GroupDead(AI.ReinforceGroup[N]))
    or (AI.ReinforceGroup[N] <> -1) then
      Actions.GroupOrderWalk(AI.ReinforceGroup[N], AI.ReinforceX[N], AI.ReinforceY[N], 0);
end;


/////////////////
//////TEXTS//////
/////////////////


//Get statistic text


procedure GetStatistic;
begin
  Mission.Statistic := '|<$18>' + '|<$50> ' + WesternOutpost.Text + '|<$51> ' + EasternOutpost.Text
  + '|<$52> ' + SouthernOutpost.Text + '|<$53> ' + NorthernOutpost.Text +'|<$54> ' + Castle.Text
  + '|<$55> ' + KillSoldiers.Text + '|<$56> ' + DestroyIron.Text + '|<$57> ' + DestroyGold.Text
  + '|<$58> ' + DestroyCoal.Text+ '|<$59> ' + DestroyMilitary.Text + '|<$60> ' + DestroyStores.Text
  + Mission.AddTaskMsg + '||<$17>' + '|<$7> ' + Mission.Teleport + Mission.Reinforcement+ '|<$12> '
  + '[$00BCDF]' + IntToStr(Mission.FoundTiles) + '[]' + ExtraGroup.Text + ResetTeleport.Text
  + TimeInvert.Text + TimeFreeze.Text;
end;


//Get scores text


procedure GetScoresText;
begin
  Mission.Scores := '|<$23>|';
  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      Mission.Scores := Mission.Scores + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'
      + ': ' + IntToStr(Players[I].FactScore) + '/' + IntToStr(Players[I].CurrentScore) + '|';
 end;

 
//Get the text on top left of screen
 
 
procedure GetText;
begin
  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      if (not States.HouseDeliveryBlocked(Players[I].WatchTower))
      and (not States.HouseRepair(Players[I].WatchTower)) then                                     //Show statistic
        Actions.OverlayTextSet(I, '<$0> ' + Mission.TimeLeft + Mission.Statistic)
      else
        if (States.HouseDeliveryBlocked(Players[I].WatchTower)) then                               //Hide statistic; show points
          Actions.OverlayTextSet(I, '<$0> ' + Mission.TimeLeft + Mission.Scores
          + '|<$11> ' + IntToStr(Mission.FactTeamScore) + '/' + IntToStr(Mission.PossibleTeamScore))
      else
        if States.HouseRepair(Players[I].WatchTower) then
          Actions.OverlayTextSet(I, '<$0> ' + Mission.TimeLeft + Players[I].AchievementsText);     //Show achievements
end;


///Get colors of counters///

//For destroyed gold mines


function GColor: AnsiString;
begin
  case DestroyGold.CurrentCount of
    0, 1: Result := '0045FF';     //Dark orange, almost red
    2..4: Result := '008CFF';     //Orange
    5:    Result := '00FFFF';     //Yellow
    6:    Result := '32CD9B';     //Yellow green
    7, 8: Result := '00FF00';     //Lime
  end;
end;


//For destroyed iron mines


function IColor: AnsiString;
begin
  case DestroyIron.CurrentCount of
    0, 1:  Result := '0045FF';    //Dark orange, almost red
    2..4:  Result := '008CFF';    //Orange
    5..7:  Result := '00FFFF';    //Yellow
    8:     Result := '32CD9B';    //Yellow green
    9, 10: Result := '00FF00';    //Lime
  end;
end;


//For destroyed coal mines


function CColor: AnsiString;
begin
  case DestroyCoal.CurrentCount of
    0, 1:  Result := '0045FF';    //Dark orange, almost red
    2..4:  Result := '008CFF';    //Orange
    5..7:  Result := '00FFFF';    //Yellow
    8:     Result := '32CD9B';    //Yellow green
    9, 10: Result := '00FF00';    //Lime
  end;
end;


//For destroyed storehouses


function StoresColor: AnsiString;
begin
  case DestroyStores.CurrentCount of
    0, 1: Result := '0045FF';     //Dark orange, almost red
    2..4: Result := '008CFF';     //Orange
    5:    Result := '00FFFF';     //Yellow
    6:    Result := '32CD9B';     //Yellow green
    7, 8: Result := '00FF00';     //Lime
  end;
end;


//For destroyed military buildings and schools


function MColor: AnsiString;
begin
  case DestroyMilitary.CurrentCount of
    0..3:   Result := '0045FF';   //Dark orange, almost red
    4..8:   Result := '008CFF';   //Orange
    9..12:  Result := '00FFFF';   //Yellow
    13, 14: Result := '32CD9B';   //Yellow green
    15, 16: Result := '00FF00';   //Lime
  end;
end;


//For defeated enemy soldiers


function SColor: AnsiString;
begin
  case (Round(KillSoldiers.CurrentCount/KillSoldiers.NeededCount) * 100) of
    0..19:  Result := '0045FF';   //Dark orange, almost red
    20..39: Result := '008CFF';   //Orange
    40..59: Result := '00FFFF';   //Yellow
    60..79: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For teleports


function TColor: AnsiString;
begin
  case Teleport.Counter of
    0..19:  Result := '0045FF';   //Dark orange, almost red
    20..39: Result := '008CFF';   //Orange
    40..59: Result := '00FFFF';   //Yellow
    60..79: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For destroyed enemy buildings


function BuildingsColor: AnsiString;
begin
  case DestroyAll.CurrentCount of
    0..14:  Result := '0045FF';   //Dark orange, almost red
    15..28: Result := '008CFF';   //Orange
    29..42: Result := '00FFFF';   //Yellow
    43..57: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For Mounted


function MountedColor: AnsiString;
begin
  case SendMounted.CurrentCount of
    0..5:   Result := '0045FF';   //Dark orange, almost red
    6..11:  Result := '008CFF';   //Orange
    12..17: Result := '00FFFF';   //Yellow
    18..23: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For Ranged


function RangedColor: AnsiString;
begin
  case SendRanged.CurrentCount of
    0..5:   Result := '0045FF';   //Dark orange, almost red
    6..11:  Result := '008CFF';   //Orange
    12..17: Result := '00FFFF';   //Yellow
    18..23: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For Melee


function MeleeColor: AnsiString;
begin
  case SendMelee.CurrentCount of
    0..5:   Result := '0045FF';   //Dark orange, almost red
    6..11:  Result := '008CFF';   //Orange
    12..17: Result := '00FFFF';   //Yellow
    18..23: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For AntiHorse


function AntiHorseColor: AnsiString;
begin
  case SendAntihorse.CurrentCount of
    0..5:   Result := '0045FF';   //Dark orange, almost red
    6..11:  Result := '008CFF';   //Orange
    12..17: Result := '00FFFF';   //Yellow
    18..23: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//For Barbarians


function BarbsColor: AnsiString;
begin
  case SendBarbs.CurrentCount of
    0..2:  Result := '0045FF';    //Dark orange, almost red
    3..5:  Result := '008CFF';    //Orange
    6..8:  Result := '00FFFF';    //Yellow
    9..11: Result := '32CD9B'     //Yellow green
    else   Result := '00FF00';    //Lime
  end;
end;


//For lost soldiers


function LostSoldiersColor: AnsiString;
begin
  case (Round(LoseNoMore.CurrentCount/LoseNoMore.NeededCount) * 100) of
    60..79: Result := '008CFF';   //Orange
    40..59: Result := '00FFFF';   //Yellow
    20..39: Result := '32CD9B';   //Yellow green
    0..19:  Result := '00FF00'    //Lime
    else    Result := '0045FF';   //Dark orange, almost red
  end;
end;


//For enemy citizens


function CitizensColor: AnsiString;
begin
  case (Round(KillAll.CurrentCount/KillAll.NeededCount) * 100) of
    0..19:  Result := '0045FF';   //Dark orange, almost red
    20..39: Result := '008CFF';   //Orange
    40..59: Result := '00FFFF';   //Yellow
    60..79: Result := '32CD9B'    //Yellow green
    else    Result := '00FF00';   //Lime
  end;
end;


//Get messages for text on top left of screen

 
procedure GetMessages;
begin

//Teleports counter

  if Teleport.Counter > 0 then
    Mission.Teleport := '[$' + TColor + ']' + IntToStr(Teleport.Counter) + ' <$6> ' + IntToStr(TELEPORTS_MAX) + '[]'                                                               //Show how much troops players can teleport
  else
    Mission.Teleport := '[$0000FF]' + ' <$9>' + '[]';                                                                                                                              //Limit is reached

//TASK: Destroy iron mines

  if (DestroyIron.CurrentCount < DestroyIron.NeededCount)
  or not (DoubleCheck.NoIronLeft) then
    DestroyIron.Text := '[$' + IColor + ']' + IntToStr(DestroyIron.CurrentCount) + ' <$6> ' + IntToStr(DestroyIron.NeededCount) + '[]'                                             //In progress...
  else
    DestroyIron.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                               //Task completed

//TASK: Destroy gold mines

  if (DestroyGold.CurrentCount < DestroyGold.NeededCount)
  or not (DoubleCheck.NoGoldLeft) then
    DestroyGold.Text := '[$' + GColor + ']' + IntToStr(DestroyGold.CurrentCount) + ' <$6> ' + IntToStr(DestroyGold.NeededCount) + '[]'                                             //In progress...
  else
    DestroyGold.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                               //Task completed

//TASK: Destroy coal mines

  if (DestroyCoal.CurrentCount < DestroyCoal.NeededCount)
  or not (DoubleCheck.NoCoalLeft) then
    DestroyCoal.Text := '[$' + CColor + ']' + IntToStr(DestroyCoal.CurrentCount) + ' <$6> ' + IntToStr(DestroyCoal.NeededCount) + '[]'                                             //In progress..
  else
    DestroyCoal.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                               //Task completed

//TASK: Destroy military complex

  if (DestroyMilitary.CurrentCount < DestroyMilitary.NeededCount)
  or not (DoubleCheck.NoMilitaryLeft) then
    DestroyMilitary.Text := '[$' + MColor + ']' + IntToStr(DestroyMilitary.CurrentCount) + ' <$6> ' + IntToStr(DestroyMilitary.NeededCount) + '[]'                                 //In progress...
  else
    DestroyMilitary.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                           //Task completed

//TASK: Destroy storehouses

  if (DestroyStores.CurrentCount < DestroyStores.NeededCount)
  or not (DoubleCheck.NoStoresLeft) then
    DestroyStores.Text := '[$' + StoresColor + ']' + IntToStr(DestroyStores.CurrentCount) + ' <$6> ' + IntToStr(DestroyStores.NeededCount) + '[]'                                  //In progress...
  else
    DestroyStores.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                             //Task completed

//TASK: Defeat enemy soldiers

  if (KillSoldiers.CurrentCount < KillSoldiers.NeededCount)
  or not (DoubleCheck.NoSoldiersLeft) then
    KillSoldiers.Text := '[$' + SColor + ']' + IntToStr(KillSoldiers.CurrentCount) + ' <$6> ' + IntToStr(KillSoldiers.NeededCount) + '[]'                                          //In progress...
  else
    KillSoldiers.Text := '[$00FF00]' + '<$5>' + '[]';                                                                                                                              //Task completed

//TASK: Take control over the Western Outpost

  if WesternOutpost.Time = POSITION_HOLD_TIME then
    WesternOutpost.Text := '[$33CCFF]' + '<$1>' + '[]'                                                                                                                             //Location is not visited yet
  else
    if WesternOutpost.Time = 0 then
      WesternOutpost.Text := '[$00FF00]' + '<$5>' + '[]'                                                                                                                           //Task completed
    else
      if not WesternOutpost.Captured then
        WesternOutpost.Text := '[$0000FF]' + '<$2>' + '[]'                                                                                                                         //Control over this location is lost
      else
      begin                                                                                                                                                                        //When location is visited - run timer
        if (WesternOutpost.Time div 10) mod 60 < 10 then
          WesternOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((WesternOutpost.Time div 600) mod 60) + ':0' + IntToStr((WesternOutpost.Time div 10) mod 60) + '[]'        //Formatting seconds: 1..9 ---> 01..09, so time will be 01:05, not 01:5
        else
          WesternOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((WesternOutpost.Time div 600) mod 60) + ':' + IntToStr((WesternOutpost.Time div 10) mod 60) + '[]';        //No need formatting, time will be e.g. 02:33
      end;

//TASK: Take control over the Eastern Outpost

  if EasternOutpost.Time = POSITION_HOLD_TIME then
    EasternOutpost.Text := '[$33CCFF]' + '<$1>' + '[]'                                                                                                                             //Location is not visited yet
  else
    if EasternOutpost.Time = 0 then
      EasternOutpost.Text := '[$00FF00]' + '<$5>' + '[]'                                                                                                                           //Task completed
    else
      if not EasternOutpost.Captured then
        EasternOutpost.Text := '[$0000FF]' + '<$2>' + '[]'                                                                                                                         //Control over this location is lost
      else
      begin                                                                                                                                                                        //When location is visited - run timer
        if (EasternOutpost.Time div 10) mod 60 < 10 then
          EasternOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((EasternOutpost.Time div 600) mod 60) + ':0' + IntToStr((EasternOutpost.Time div 10) mod 60) + '[]'        //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:05, not 01:5
        else
          EasternOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((EasternOutpost.Time div 600) mod 60) + ':' + IntToStr((EasternOutpost.Time div 10) mod 60) + '[]';        //No need formatting, time will be e.g. 02:33
      end;

//TASK: Take control over the Southern Outpost

  if SouthernOutpost.Time = POSITION_HOLD_TIME then
    SouthernOutpost.Text := '[$33CCFF]' + '<$1>' + '[]'                                                                                                                            //Location is not visited yet
  else
    if SouthernOutpost.Time = 0 then
      SouthernOutpost.Text := '[$00FF00]' + '<$5>' + '[]'                                                                                                                          //Task completed
    else
      if not SouthernOutpost.Captured then
        SouthernOutpost.Text := '[$0000FF]' + '<$2>' + '[]'                                                                                                                        //Control over this location is lost
      else
      begin                                                                                                                                                                        //When location is visited - run timer
        if (SouthernOutpost.Time div 10) mod 60 < 10 then
          SouthernOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((SouthernOutpost.Time div 600) mod 60) + ':0' + IntToStr((SouthernOutpost.Time div 10) mod 60) + '[]'     //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:05, not 01:5
        else
          SouthernOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((SouthernOutpost.Time div 600) mod 60) + ':' + IntToStr((SouthernOutpost.Time div 10) mod 60) + '[]';     //No need formatting, time will be e.g. 02:33
      end;

//TASK: Take control over the Northern Outpost

  if NorthernOutpost.Time = POSITION_HOLD_TIME then
    NorthernOutpost.Text := '[$33CCFF]' + '<$1>' + '[]'                                                                                                                             //Location is not visited yet
  else
    if NorthernOutpost.Time = 0 then
      NorthernOutpost.Text := '[$00FF00]' + '<$5>' + '[]'                                                                                                                          //Task completed
    else
      if not NorthernOutpost.Captured then
        NorthernOutpost.Text := '[$0000FF]' + '<$2>' + '[]'                                                                                                                         //Control over this location is lost
      else
      begin                                                                                                                                                                        //When location is visited - run timer
        if (NorthernOutpost.Time div 10) mod 60 < 10 then
          NorthernOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((NorthernOutpost.Time div 600) mod 60) + ':0' + IntToStr((NorthernOutpost.Time div 10) mod 60) + '[]'     //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:05, not 01:5
        else
          NorthernOutpost.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((NorthernOutpost.Time div 600) mod 60) + ':' + IntToStr((NorthernOutpost.Time div 10) mod 60) + '[]';     //No need formatting, time will be e.g. 02:33
      end;

//TASK: Take control over The Castle

  if Castle.Time = POSITION_HOLD_TIME then
    Castle.Text := '[$33CCFF]' + '<$1>' + '[]'                                                                                                                                     //Location is not visited yet
  else
    if Castle.Time = 0 then
      Castle.Text := '[$00FF00]' + '<$5>' + '[]'                                                                                                                                   //Task completed
    else
      if (Castle.Time = POSITION_VISITED_TIME)
      and (DestroyMilitary.CurrentCount < DestroyMilitary.NeededCount) then
        Castle.Text := '[$33CCFF]' + '<$3>' + '[]'                                                                                                                                 //You have to destroy military complex first
      else
        if (not Castle.Captured)
        or ((Castle.Time = POSITION_VISITED_TIME)
        and (DestroyMilitary.CurrentCount = DestroyMilitary.NeededCount)) then
          Castle.Text := '[$0000FF]' + '<$2>' + '[]'                                                                                                                               //Control over this location is lost
      else
      begin                                                                                                                                                                        //When location is visited - run timer
        if (Castle.Time div 10) mod 60 < 10 then
          Castle.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((Castle.Time div 600) mod 60) + ':0' + IntToStr((Castle.Time div 10) mod 60) + '[]'                                //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:05, not 01:5
        else
          Castle.Text := '[$CC9900]' + '<$4> ' + '0' + IntToStr((Castle.Time div 600) mod 60) + ':' + IntToStr((Castle.Time div 10) mod 60) + '[]';                                //No need formatting, time will be e.g. 02:33
      end;
end;


///////////////////////////////
//////TIMERS AND COUNTERS//////
///////////////////////////////


//Scores for each killed soldier


function Score(aUnitID: Integer): Integer; 
begin
  case States.UnitType(aUnitID) of
    14:  Result := 1;        //Militia
    15:  Result := 3;        //Axe Fighter
    16:  Result := 5;        //Sword Fighter
    17:  Result := 2;        //Bowman
    18:  Result := 2;        //Crossbowman
    19:  Result := 2;        //Lance Carrier
    20:  Result := 3;        //Pikeman
    21:  Result := 4;        //Scout
    22:  Result := 7;        //Knight
    23:  Result := 5;        //Barbarian
    24:  Result := 1;        //Rebel
    25:  Result := 1;        //Rogue
    26:  Result := 5;        //Warrior
    27:  Result := 2;        //Vagabond
    else Result := 0;        //Civilians
  end;
end;


//Penalties for every lost soldier


procedure GetPenaltyScore;
begin

//Decrease poits for lost units

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
      Players[I].FactScore := Players[I].CurrentScore - 2 * (1 * States.StatUnitLostCount(I, 14)   //Every lost soldier decreases score
      + 3 * States.StatUnitLostCount(I, 15) + 5 * States.StatUnitLostCount(I, 16)
      + 2 * States.StatUnitLostCount(I, 17) + 2 * States.StatUnitLostCount(I, 18)
      + 2 * States.StatUnitLostCount(I, 19) + 3 * States.StatUnitLostCount(I, 20)
      + 4 * States.StatUnitLostCount(I, 21) + 7 * States.StatUnitLostCount(I, 22)
      + 5 * States.StatUnitLostCount(I, 23) + 1 * States.StatUnitLostCount(I, 24)
      + 1 * States.StatUnitLostCount(I, 25) + 5 * States.StatUnitLostCount(I, 26)
      + 2 * States.StatUnitLostCount(I, 27)) + 2 * (1 * Teleport.UnitsCount[I][0]                  //Don't count teleports
      + 3 * Teleport.UnitsCount[I][1] + 5 * Teleport.UnitsCount[I][2]
      + 2 * Teleport.UnitsCount[I][3] + 2 * Teleport.UnitsCount[I][4]
      + 2 * Teleport.UnitsCount[I][5] + 3 * Teleport.UnitsCount[I][6]
      + 4 * Teleport.UnitsCount[I][7] + 7 * Teleport.UnitsCount[I][8]
      + 5 * Teleport.UnitsCount[I][9] + 1 * Teleport.UnitsCount[I][10]
      + 1 * Teleport.UnitsCount[I][11] + 5 * Teleport.UnitsCount[I][12]
      + 2 * Teleport.UnitsCount[I][13]);
end;


//Reinforcement timer


procedure GetReinforcementTimer;
var
  Secs: AnsiString;
begin

  if Mission.ReinforcementTime > 0 then
    Mission.ReinforcementTime := Mission.ReinforcementTime - 1;

  if (Mission.ReinforcementTime div 10) mod 60 < 10 then
    Secs := '0' + IntToStr((Mission.ReinforcementTime div 10) mod 60)                                                                 //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:05, not 01:5
  else
    Secs := IntToStr((Mission.ReinforcementTime div 10) mod 60);                                                                      //No need formatting, time will be e.g. 01:25

  Mission.Reinforcement :='|<$8>' + '[$CC9900]' + ' 0' + IntToStr((Mission.ReinforcementTime div 600) mod 60) + ':' + Secs + '[]';    //The whole reinforcement timer string
end;


//Count destroyed buildings

 
procedure OnHouseDestroyed(aHouseID, aDestroyerIndex: Integer);
begin
  if (States.HouseOwner(aHouseID) = 7)
  and (aDestroyerIndex >= 0)
  and (aDestroyerIndex <= 3) then
  begin
    Demolisher.FactCount[aDestroyerIndex] := Demolisher.FactCount[aDestroyerIndex] + 1;
    Players[aDestroyerIndex].CurrentScore := Players[aDestroyerIndex].CurrentScore + BUILDING_DEMOLISH_SCORE;

    case States.HouseType(aHouseID) of
      3: begin
           DestroyCoal.CurrentCount := DestroyCoal.CurrentCount + 1;                               //Coal mines
           DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                 //Destroyed enemy buildings
         end;

     4: begin
          DestroyIron.CurrentCount := DestroyIron.CurrentCount + 1;                                //Iron mines
          DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                  //Destroyed enemy buildings
        end;

     5: begin
          DestroyGold.CurrentCount := DestroyGold.CurrentCount + 1;                                //Gold mines
          DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                  //Destroyed enemy buildings
        end;

     11: begin
           DestroyStores.CurrentCount := DestroyStores.CurrentCount + 1;                           //Storehouses
           DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                 //Destroyed enemy buildings
         end;

     1,                                                                                            //Iron smithies
     2,                                                                                            //Weapon smithies
     10,                                                                                           //Armor smithies
     13,                                                                                           //Schools
     19,                                                                                           //Weapon workshops
     20,                                                                                           //Armory workshops
     21: begin                                                                                     //Barracks
           DestroyMilitary.CurrentCount := DestroyMilitary.CurrentCount + 1;                       //Military buldings and schools
           DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                 //Destroyed enemy buildings
         end;

     else
     begin
       DestroyAll.CurrentCount := DestroyAll.CurrentCount + 1;                                     //Destroyed enemy buildings
     end;
    end;
  end;
end;


//Count equipped soldiers and update number of soldiers we have to kill; also update number of citizens


procedure OnWarriorEquipped(aUnitID, aGroupID: Integer);
begin
  if States.UnitOwner(aUnitID) = 7 then
  begin
    KillSoldiers.NeededCount := KillSoldiers.NeededCount + 1;
    KillAll.NeededCount := KillAll.NeededCount - 1;             //Recruits are citizens but soldiers aren't
  end;
end;


//Count trained citizens and update number of citizens that we have to kill


procedure OnUnitTrained(aUnitID: Integer);
begin
  if (States.UnitOwner(aUnitID) = 7)
  and (States.UnitType(aUnitID) >= 0)
  and (States.UnitType(aUnitID) <= 13) then
    KillAll.NeededCount := KillAll.NeededCount + 1;
end;


//Count killed soldiers, citizens, lost soldiers; Count number of teleports


procedure OnUnitDied(aUnitID, aKillerIndex: Integer);
begin

//Message about AI trying to take control over outposts

  if (OutpostDefenseDead)
  and (not Mission.OutpostCaptureMsg) then
  begin
    Actions.ShowMsg(-1, '<$37>');
    Mission.OutpostCaptureMsg := True;
  end;

//Scores for killed soldiers

  if (aKillerIndex <> -1)
  and (aKillerIndex <= 3) then
    Players[aKillerIndex].CurrentScore := Players[aKillerIndex].CurrentScore + Score(aUnitID);

//Killed soldiers

  if (States.UnitOwner(aUnitID) >= 4)                                     //AI players
  and (States.UnitType(aUnitID) >= 14)                                    //Count only soldiers
  and (States.UnitType(aUnitID) <= 27) then                               //Count only soldiers
    KillSoldiers.CurrentCount := KillSoldiers.CurrentCount + 1;

//Teleports count

  if (States.UnitOwner(aUnitID) <= 3)                                     //Human players
  and (States.UnitOwner(aUnitID) >= 0)                                    //Human players
  and (Teleport.Counter > 0)
  and (aKillerIndex = -1)                                                 //Unit died from Actions.UnitKill
  and ((States.UnitPositionX(aUnitID) = 4)
  or (States.UnitPositionX(aUnitID) = 154))                               //Check only deaths on teleport bridges!
  and (States.UnitPositionY(aUnitID) = 133) then
  begin
    Teleport.Counter := Teleport.Counter - 1;
    for I := 0 to 13 do
    for J := 0 to 3 do
      if (States.UnitType(aUnitID) = I + 14)
      and (States.UnitOwner(aUnitID) = J) then
        Teleport.UnitsCount[J][I] := Teleport.UnitsCount[J][I] + 1;
  end;

//Killed citizens

  if (States.UnitOwner(aUnitID) = 7)                                      //AI player 7
  and (States.UnitType(aUnitID) >= 0)                                     //Count only citizens
  and (States.UnitType(aUnitID) <= 13) then                               //Count only citizens
    KillAll.CurrentCount := KillAll.CurrentCount + 1;

//Lost soldiers

  if (States.UnitOwner(aUnitID) >= 0)                                     //Human players
  and (States.UnitOwner(aUnitID) <= 3)                                    //Human players
  and (States.UnitType(aUnitID) >= 14)                                    //Count only soldiers
  and (States.UnitType(aUnitID) <= 27) then                               //Count only soldiers
    LoseNoMore.CurrentCount := LoseNoMore.CurrentCount + 1;

//For Achievements

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      MeatGrinder.FactCount[I] := States.StatUnitKilledMultipleTypesCount(I, [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]);
      Killer.FactCount[I]      := States.StatUnitKilledMultipleTypesCount(I, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]);
    end;
end;

 
//Get general timer colors


procedure GetLTColor;
begin
  if (Mission.Time <= GAME_TIME)
  and (Mission.Time > 54000) then
    Mission.TimerColor := '00FF00'                         //A lot of time: color is lome
  else
    if (Mission.Time <= 54000)
    and (Mission.Time > 36000) then
      Mission.TimerColor := '32CD9B'                       //Enough time: color is yellow green
  else
    if (Mission.Time <= 36000)
    and (Mission.Time > 18000) then
      Mission.TimerColor := '00FFFF'                       //Not so much time left: color is yellow
  else
    if (Mission.Time <= 18000)
    and (Mission.Time > 12000) then
      Mission.TimerColor := '008CFF'                       //Little time left: color is orange
  else
    if (Mission.Time <= 12000)
    and (Mission.Time > 6000) then
      Mission.TimerColor := '0045FF'                       //Very little time left: color is dark orange
  else
    if (Mission.Time <= 6000)
    and (Mission.Time >= 0) then
      Mission.TimerColor := '0000FF';                      //Time will end soon: color is red
end;


//Get time for general timer


procedure GetTimeLeft;
begin
  if (Mission.Time > 0)
  and (not Mission.Ended) then
    Mission.Time := Mission.Time - 1;                                                                                                                          //Less and less time each tick

  if (Mission.Time div 600) mod 60 < 10 then
    Mission.Minutes := '0' + IntToStr((Mission.Time div 600) mod 60)                                                                                           //Formatting minutes: 1..9 ---> 01..09, so time will be e.g. 01:05:55, not 01:5:55
  else
    Mission.Minutes := IntToStr((Mission.Time div 600) mod 60);                                                                                                //No need formatting, time will be e.g. 01:33:33

  if (Mission.Time div 10) mod 60 < 10 then
    Mission.Seconds := '0' + IntToStr((Mission.Time div 10) mod 60)                                                                                            //Formatting seconds: 1..9 ---> 01..09, so time will be e.g. 01:25:05, not 01:25:5
  else
    Mission.Seconds := IntToStr((Mission.Time div 10) mod 60);                                                                                                 //No need formatting, time will be e.g. 01:33:33

  Mission.TimeLeft := '[$' + Mission.TimerColor + ']' + '0' + IntToStr(Mission.Time div 36000) + ':' + Mission.Minutes + ':' + Mission.Seconds + '[]';         //The whole general timer string
end;


///Reset timers back to 5 minutes if control over location is lost///

//For western outpost


procedure ResetWTimer;
begin
   if (WesternOutpost.Visited)
   and not (WesternOutpost.Captured)
   and (WesternOutpost.Time > 0) then
     WesternOutpost.Time := POSITION_VISITED_TIME;         //We already visited this location, so time = 2999 (3000 - 1) ticks
end;


//For eastern outpost


procedure ResetETimer;
begin
  if (EasternOutpost.Visited)
  and not (EasternOutpost.Captured)
  and (EasternOutpost.Time > 0) then
    EasternOutpost.Time := POSITION_VISITED_TIME;          //We already visited this location, so time = 2999 (3000 - 1) ticks
end;


//For southern outpost


procedure ResetSTimer;
begin
  if (SouthernOutpost.Visited)
  and not (SouthernOutpost.Captured)
  and (SouthernOutpost.Time > 0) then
    SouthernOutpost.Time := POSITION_VISITED_TIME;         //We already visited this location, so time = 2999 (3000 - 1) ticks
end;


//For northern outpost


procedure ResetNTimer;
begin
  if (NorthernOutpost.Visited)
  and not (NorthernOutpost.Captured)
  and (NorthernOutpost.Time > 0) then
    NorthernOutpost.Time := POSITION_VISITED_TIME;         //We already visited this location, so time = 2999 (3000 - 1) ticks
end;


//For the Castle


procedure ResetCTimer;
begin
  if (Castle.Visited)
  and not (Castle.Captured)
  and (Castle.Time > 0) then
    Castle.Time := POSITION_VIS_CAPTURED_TIME;             //We already visited this locationand tried to capture it, so time = 2998 (3000 - 1 - 1) ticks
end;


////////////////////////
//////ACHIEVEMENTS//////
////////////////////////


//Calculate soldiers type for Pirate achievement bonus


function GetTHUnit: Integer;
begin
  case States.KaMRandomI(6) of
    0, 4:     Result := 24;  //Rebel
    1:        Result := 25;  //Rogue
    2, 5:     Result := 14;  //Militia
    3:        Result := 27;  //Vagabond
  end;
end;


//Get Achievements


procedure GetAchievements;
begin

//Novice Scout

 for I := 0 to 3 do
 begin
   if (AreaRevealed(I, 65, 128))
   and (AreaRevealed(I, 25, 97))
   and (AreaRevealed(I, 95, 128))
   and (AreaRevealed(I, 135, 97))
   and (not NoviceScout.Get) then
   begin

     if States.PlayerEnabled(0) then
       Actions.GiveGroup(0, 21, Players[0].SpawnX[0], Players[0].SpawnY[0], Players[0].Direction, ACHIEVEMENTS_NOVICE_SCOUTS, 3);

     if States.PlayerEnabled(1) then
       Actions.GiveGroup(1, 21, Players[1].SpawnX[0], Players[1].SpawnY[0], Players[1].Direction, ACHIEVEMENTS_NOVICE_SCOUTS, 3);

     if States.PlayerEnabled(2) then
       Actions.GiveGroup(2, 21, Players[2].SpawnX[0], Players[2].SpawnY[0], Players[2].Direction, ACHIEVEMENTS_NOVICE_SCOUTS, 3);

     if States.PlayerEnabled(3) then
       Actions.GiveGroup(3, 21, Players[3].SpawnX[0], Players[3].SpawnY[0], Players[3].Direction, ACHIEVEMENTS_NOVICE_SCOUTS, 3);

     Actions.ShowMsgFormatted(-1, '<$33>' + ' <$125>' + ', <$150>' + ' <$34>' + ' <$175>', [ACHIEVEMENTS_NOVICE, '%', ACHIEVEMENTS_NOVICE_SCOUTS]);
     NoviceScout.Get := True;
     Exit;
   end;
 end;

//PRO Scout

  for I := 0 to 3 do
  begin
    if (NoviceScout.Get)
    and (AreaRevealed(I, 80, 103))
    and (AreaRevealed(I, 80, 20))
    and (AreaRevealed(I, 14, 14))
    and (AreaRevealed(I, 144, 14))
    and (AreaRevealed(I, 124, 50))
    and (AreaRevealed(I, 34, 50))
    and (AreaRevealed(I, 5, 58))
    and (AreaRevealed(I, 155, 58))
    and (not ProScout.Get) then
    begin
      Actions.ShowMsgFormatted(-1, '<$33>' + ' <$126>' + ', <$151>' + ' <$34>' + ' <$175>', [ACHIEVEMENTS_PRO, '%', ACHIEVEMENTS_PRO_SCOUTS]);

      if States.PlayerEnabled(0) then
        Actions.GiveGroup(0, 21, Players[0].SpawnX[0], Players[0].SpawnY[0], Players[0].Direction, ACHIEVEMENTS_PRO_SCOUTS, 4);

      if States.PlayerEnabled(1) then
        Actions.GiveGroup(1, 21, Players[1].SpawnX[0], Players[1].SpawnY[0], Players[1].Direction, ACHIEVEMENTS_PRO_SCOUTS, 4);

      if States.PlayerEnabled(2) then
        Actions.GiveGroup(2, 21, Players[2].SpawnX[0], Players[2].SpawnY[0], Players[2].Direction, ACHIEVEMENTS_PRO_SCOUTS, 4);

      if States.PlayerEnabled(3) then
        Actions.GiveGroup(3, 21, Players[3].SpawnX[0], Players[3].SpawnY[0], Players[3].Direction, ACHIEVEMENTS_PRO_SCOUTS, 4);

      ProScout.Get := True;
      Exit;
    end;
  end;

//Counterintelligence

  if (States.GroupDead(AI.Patrol[0]))
  and (States.GroupDead(AI.Patrol[1]))
  and (States.GroupDead(AI.Patrol[2]))
  and (States.GroupDead(AI.Patrol[3]))
  and (not Counterintelligence.Get) then
  begin
    Actions.ShowMsgFormatted(-1, '<$33>' + ' <$127>' + ', <$152>' + ' <$34>' + ' <$175>', [ACHIEVEMENTS_COUNTER_SCOUTS]);

    if States.PlayerEnabled(0) then
      Actions.GiveGroup(0, 21, Players[0].SpawnX[0], Players[0].SpawnY[0], Players[0].Direction, ACHIEVEMENTS_COUNTER_SCOUTS, 3);

    if States.PlayerEnabled(1) then
      Actions.GiveGroup(1, 21, Players[1].SpawnX[0], Players[1].SpawnY[0], Players[1].Direction, ACHIEVEMENTS_COUNTER_SCOUTS, 3);

    if States.PlayerEnabled(2) then
      Actions.GiveGroup(2, 21, Players[2].SpawnX[0], Players[2].SpawnY[0], Players[2].Direction, ACHIEVEMENTS_COUNTER_SCOUTS, 3);

    if States.PlayerEnabled(3) then
      Actions.GiveGroup(3, 21, Players[3].SpawnX[0], Players[3].SpawnY[0], Players[3].Direction, ACHIEVEMENTS_COUNTER_SCOUTS, 3);

    Counterintelligence.Get := True;
    Exit;
  end;

//Race against the clock

  for I := 0 to 3 do
  begin
    if (Counterintelligence.Get)
    and (AreaRevealed(I, 73, 70))
    and (AreaRevealed(I, 83, 70))
    and (States.GameTime < ACHIEVEMENTS_RACE)
    and (not Race.Get) then
    begin
      Actions.ShowMsgFormatted(-1, '<$33>' + ' <$128>' + ', <$153>' + ' <$34>' + ' <$176>', [ACHIEVEMENTS_RACE_SWORDS, ACHIEVEMENTS_RACE_BOWS, ACHIEVEMENTS_RACE_KNIGHTS]);

      if States.PlayerEnabled(0) then
      begin
        Actions.GiveGroup(0, 16, Players[0].SpawnX[0], Players[0].SpawnY[0], Players[0].Direction, ACHIEVEMENTS_RACE_SWORDS, 3);
        Actions.GiveGroup(0, 17, Players[0].SpawnX[1], Players[0].SpawnY[1], Players[0].Direction, ACHIEVEMENTS_RACE_BOWS, 3);
        Actions.GiveGroup(0, 22, Players[0].SpawnX[2], Players[0].SpawnY[2], Players[0].Direction, ACHIEVEMENTS_RACE_KNIGHTS, 2);
      end;

      if States.PlayerEnabled(1) then
      begin
        Actions.GiveGroup(1, 16, Players[1].SpawnX[0], Players[1].SpawnY[0], Players[1].Direction, ACHIEVEMENTS_RACE_SWORDS, 3);
        Actions.GiveGroup(1, 17, Players[1].SpawnX[1], Players[1].SpawnY[1], Players[1].Direction, ACHIEVEMENTS_RACE_BOWS, 3);
        Actions.GiveGroup(1, 22, Players[1].SpawnX[2], Players[1].SpawnY[2], Players[1].Direction, ACHIEVEMENTS_RACE_KNIGHTS, 2);
      end;

      if States.PlayerEnabled(2) then
      begin
        Actions.GiveGroup(2, 16, Players[2].SpawnX[0], Players[2].SpawnY[0], Players[2].Direction, ACHIEVEMENTS_RACE_SWORDS, 3);
        Actions.GiveGroup(2, 17, Players[2].SpawnX[1], Players[2].SpawnY[1], Players[2].Direction, ACHIEVEMENTS_RACE_BOWS, 3);
        Actions.GiveGroup(2, 22, Players[2].SpawnX[2], Players[2].SpawnY[2], Players[2].Direction, ACHIEVEMENTS_RACE_KNIGHTS, 2);
      end;

      if States.PlayerEnabled(3) then
      begin
        Actions.GiveGroup(3, 16, Players[3].SpawnX[0], Players[3].SpawnY[0], Players[3].Direction, ACHIEVEMENTS_RACE_SWORDS, 3);
        Actions.GiveGroup(3, 17, Players[3].SpawnX[1], Players[3].SpawnY[1], Players[3].Direction, ACHIEVEMENTS_RACE_BOWS, 3);
        Actions.GiveGroup(3, 22, Players[3].SpawnX[2], Players[3].SpawnY[2], Players[3].Direction, ACHIEVEMENTS_RACE_KNIGHTS, 2);
      end;

      Race.Get := True;
      Exit;
    end;
  end;

//Pirate

  for I := 0 to 3 do
  begin
    if (AreaRevealed(I, 100, 10))
    and (AreaRevealed(I, 60, 9))
    and ((States.GroupDead(AI.Pirates[0]))
    or (AI.Pirates[0] = -1))
    and ((States.GroupDead(AI.Pirates[1]))
    or (AI.Pirates[1] = -1))
    and (not Pirate.Get) then
    begin
      Actions.ShowMsg(-1, '<$33>' + ' <$141>' + ', <$166>' + ' <$34>' + ' <$188>');
      Pirate.Get := True;
      Exit;
    end;
  end;

//Meat Grinder

  for I := 0 to 3 do
    if (MeatGrinder.FactCount[I] >= ACHIEVEMENTS_MEAT_GRINDER)
    and (States.PlayerEnabled(I))
    and (not MeatGrinder.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$129>' + ', <$154>' + ' <$34>' + ' <$177>', [ACHIEVEMENTS_MEAT_GRINDER, ACHIEVEMENTS_MEAT_KNIGHTS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 22, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_MEAT_KNIGHTS, 3);

      if MeatGrinder.GetBy = '' then
        MeatGrinder.GetBy := MeatGrinder.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                //Add name of the player who got the achievement
      else
        MeatGrinder.GetBy := MeatGrinder.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                        //Add name of the player who got the achievement and separator , between names
 
      MeatGrinder.Get[I] := True;
      Exit;
    end;

//Killer

  for I := 0 to 3 do
    if (Killer.FactCount[I] >= ACHIEVEMENTS_KILLER)
    and (States.PlayerEnabled(I))
    and (not Killer.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$130>' + ', <$155>' + ' <$34>' + ' <$178>', [ACHIEVEMENTS_KILLER, ACHIEVEMENTS_KILLER_BARBS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 23, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_KILLER_BARBS, 2);

      if Killer.GetBy = '' then
        Killer.GetBy := Killer.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                          //Add name of the player who got the achievement
      else
        Killer.GetBy := Killer.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                  //Add name of the player who got the achievement and separator , between names
 
      Killer.Get[I] := True;
      Exit;
    end;

//Demolisher

  for I := 0 to 3 do
    if (Demolisher.FactCount[I] >= ACHIEVEMENTS_DEMOLISHER)
    and (States.PlayerEnabled(I))
    and (not Demolisher.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$131>' + ', <$156>' + ' <$34>' + ' <$179>', [ACHIEVEMENTS_DEMOLISHER, ACHIEVEMENTS_DEMOLISHER_BOWS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 17, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_DEMOLISHER_BOWS, 3);

      if Demolisher.GetBy = '' then
        Demolisher.GetBy := Demolisher.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                  //Add name of the player who got the achievement
      else
        Demolisher.GetBy := Demolisher.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                          //Add name of the player who got the achievement and separator , between names

      Demolisher.Get[I] := True;
      Exit;
    end;

//Knight

  for I := 0 to 3 do
    if (UnitsCount(I, 22) >= Knight.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not Knight.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$132>' + ': <$157>' + ' <$34>' + ' <$177>', [Knight.NeededCount[I], ACHIEVEMENTS_KNIGHT_KNIGHTS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 22, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_KNIGHT_KNIGHTS, 3);

      if Knight.GetBy = '' then
        Knight.GetBy := Knight.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                          //Add name of the player who got the achievement
      else
        Knight.GetBy := Knight.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                  //Add name of the player who got the achievement and separator , between names

      Knight.Get[I] := True;
      Exit;
    end;

//Iron Man

  for I := 0 to 3 do
    if (UnitsCount(I, 16)
    + UnitsCount(I, 18)
    + UnitsCount(I, 20)
    + UnitsCount(I, 22) >= IronMan.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not IronMan.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$139>' + ': <$164>' + ' <$34>' + ' <$186>', [IronMan.NeededCount[I], ACHIEVEMENTS_IRON_SWORDS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 16, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_IRON_SWORDS, 4);

      if IronMan.GetBy = '' then
        IronMan.GetBy := IronMan.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                        //Add name of the player who got the achievement
      else
        IronMan.GetBy := IronMan.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                //Add name of the player who got the achievement and separator , between names

      IronMan.Get[I] := True;
      Exit;
    end;

//Barbarian's Boss

  for I := 0 to 3 do
    if (UnitsCount(I, 23) >= BarbsBoss.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not BarbsBoss.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$137>' + ': <$162>' + ' <$34>' + ' <$184>', [BarbsBoss.NeededCount[I], ACHIEVEMENTS_BARBS_BOSS_WARRIORS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 26, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_BARBS_BOSS_WARRIORS, 3);

      if BarbsBoss.GetBy = '' then
        BarbsBoss.GetBy := BarbsBoss.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                    //Add name of the player who got the achievement
      else
        BarbsBoss.GetBy := BarbsBoss.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                            //Add name of the player who got the achievement and separator , between names

      BarbsBoss.Get[I] := True;
      Exit;
    end;

//Leather Man

  for I := 0 to 3 do
    if (UnitsCount(I, 15)
    + UnitsCount(I, 17)
    + UnitsCount(I, 19)
    + UnitsCount(I, 21) >= LeatherMan.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not LeatherMan.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$140>' + ': <$165>' + ' <$34>' + ' <$187>', [LeatherMan.NeededCount[I], ACHIEVEMENTS_LEATHER_AXES]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 15, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_LEATHER_AXES, 4);

      if LeatherMan.GetBy = '' then
        LeatherMan.GetBy := LeatherMan.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                  //Add name of the player who got the achievement
      else
        LeatherMan.GetBy := LeatherMan.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                          //Add name of the player who got the achievement and separator , between names

      LeatherMan.Get[I] := True;
      Exit;
    end;

//Variety, almost impossible to get it ;D

  for I := 0 to 3 do
    if (UnitsCount(I, 15) >= Variety.NeededCount[I])
    and (UnitsCount(I, 16) >= Variety.NeededCount[I])
    and (UnitsCount(I, 17) >= Variety.NeededCount[I])
    and (UnitsCount(I, 18) >= Variety.NeededCount[I])
    and (UnitsCount(I, 19) >= Variety.NeededCount[I])
    and (UnitsCount(I, 20) >= Variety.NeededCount[I])
    and (UnitsCount(I, 21) >= Variety.NeededCount[I])
    and (UnitsCount(I, 22) >= Variety.NeededCount[I])
    and (UnitsCount(I, 23) >= Variety.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not Variety.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$138>' + ': <$163>' + ' <$34>' + ' <$185>', [Variety.NeededCount[I], ACHIEVEMENTS_VARIETY_BOWS, ACHIEVEMENTS_VARIETY_BARBS]);
     if States.PlayerEnabled(I) then
     begin
       Actions.GiveGroup(I, 17, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_VARIETY_BOWS, 3);
       Actions.GiveGroup(I, 23, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_VARIETY_BARBS, 3);
     end;

     if Variety.GetBy = '' then
       Variety.GetBy := Variety.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                         //Add name of the player who got the achievement
     else
       Variety.GetBy := Variety.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                 //Add name of the player who got the achievement and separator , between names

     Variety.Get[I] := True;
     Exit;
   end;

//Hooooorses

  for I := 0 to 3 do
    if (UnitsCount(I, 21)
    + UnitsCount(I, 22) >= Horses.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not Horses.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$133>' + ': <$158>' + ' <$34>' + ' <$180>', [Horses.NeededCount[I], ACHIEVEMENTS_HORSES_SCOUTS, ACHIEVEMENTS_HORSES_KNIGHTS]);
      if States.PlayerEnabled(I) then
      begin
        Actions.GiveGroup(I, 21, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_HORSES_SCOUTS, 2);
        Actions.GiveGroup(I, 22, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_HORSES_KNIGHTS, 2);
      end;

      if Horses.GetBy = '' then
        Horses.GetBy := Horses.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                          //Add name of the player who got the achievement
      else
        Horses.GetBy := Horses.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                  //Add name of the player who got the achievement and separator , between names

      Horses.Get[I] := True;
      Exit;
    end;

//Into Spears!

  for I := 0 to 3 do
    if (UnitsCount(I, 19)
    + UnitsCount(I, 20) >= IntoSpears.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not IntoSpears.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$135>' + ': <$160>' + ' <$34>' + ' <$182>', [IntoSpears.NeededCount[I], ACHIEVEMENTS_INTO_SPEARS_PIKES]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 20, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_INTO_SPEARS_PIKES, 3);

      if IntoSpears.GetBy = '' then
        IntoSpears.GetBy := IntoSpears.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                  //Add name of the player who got the achievement
      else
        IntoSpears.GetBy := IntoSpears.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                          //Add name of the player who got the achievement and separator , between names
 
      IntoSpears.Get[I] := True;
      Exit;
    end;

//Shooter

  for I := 0 to 3 do
    if (UnitsCount(I, 17)
    + UnitsCount(I, 18) >= Shooter.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not Shooter.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$134>' + ': <$159>' + ' <$34>' + ' <$181>', [Shooter.NeededCount[I], ACHIEVEMENTS_SHOOTER_CROSSBOWS]);
      if States.PlayerEnabled(I) then
        Actions.GiveGroup(I, 18, Players[I].SpawnX[0], Players[I].SpawnY[0], Players[I].Direction, ACHIEVEMENTS_SHOOTER_CROSSBOWS, 3);

      if Shooter.GetBy = '' then
        Shooter.GetBy := Shooter.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                        //Add name of the player who got the achievement
      else
        Shooter.GetBy := Shooter.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                //Add name of the player who got the achievement and separator , between names

      Shooter.Get[I] := True;
      Exit;
    end;

//Infantryman

  for I := 0 to 3 do
    if (UnitsCount(I, 15)
    + UnitsCount(I, 16) >= Infantryman.NeededCount[I])
    and (States.PlayerEnabled(I))
    and (not Infantryman.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$136>' + ': <$161>' + ' <$34>' + ' <$183>', [Infantryman.NeededCount[I], ACHIEVEMENTS_INFANTRYMAN_AXES, ACHIEVEMENTS_INFANTRYMAN_SWORDS]);
      if States.PlayerEnabled(I) then
      begin
        Actions.GiveGroup(I, 15, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_INFANTRYMAN_AXES, 3);
        Actions.GiveGroup(I, 16, Players[I].SpawnX[2], Players[I].SpawnY[2], Players[I].Direction, ACHIEVEMENTS_INFANTRYMAN_SWORDS, 2);
      end;

      if Infantryman.GetBy = '' then
        Infantryman.GetBy := Infantryman.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                //Add name of the player who got the achievement
      else
        Infantryman.GetBy := Infantryman.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                        //Add name of the player who got the achievement and separator , between names

      Infantryman.Get[I] := True;
      Exit;
    end;

//Rebel

  for I := 0 to 3 do
    if (UnitsCount(I, 14)
    + UnitsCount(I, 24)
    + UnitsCount(I, 25)
    + UnitsCount(I, 27) >= ACHIEVEMENTS_REBEL)
    and (States.PlayerEnabled(I))
    and (not Rebel.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$142>' + ': <$167>' + ' <$34>' + ' <$189>', [ACHIEVEMENTS_REBEL, ACHIEVEMENTS_REBEL_REBELS]);
      if States.PlayerEnabled(I) then
      begin
        Actions.GiveGroup(I, 24, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_REBEL_REBELS, 3);
      end;

      if Rebel.GetBy = '' then
        Rebel.GetBy := Rebel.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                            //Add name of the player who got the achievement
      else
        Rebel.GetBy := Rebel.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                    //Add name of the player who got the achievement and separator , between names

      Rebel.Get[I] := True;
      Exit;
    end;

//301st Spartan

  for I := 0 to 3 do
    if (ArmyCount(I) >= ACHIEVEMENTS_SPARTAN)
    and (States.PlayerEnabled(I))
    and (not Spartan.Get[I]) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$143>' + ': <$168>' + ' <$34>' + ' <$190>', [ACHIEVEMENTS_SPARTAN, ACHIEVEMENTS_SPARTAN_KNIGHTS, ACHIEVEMENTS_SPARTAN_SWORDS]);
      if States.PlayerEnabled(I) then
      begin
        Actions.GiveGroup(I, 22, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_SPARTAN_KNIGHTS, 3);
        Actions.GiveGroup(I, 16, Players[I].SpawnX[2], Players[I].SpawnY[2], Players[I].Direction, ACHIEVEMENTS_SPARTAN_SWORDS, 3);
      end;

      if Spartan.GetBy = '' then
        Spartan.GetBy := Spartan.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                                        //Add name of the player who got the achievement
      else
        Spartan.GetBy := Spartan.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                                //Add name of the player who got the achievement and separator , between names

      Spartan.Get[I] := True;
      Exit;
    end;

//Second Chance

  for I := 0 to 3 do
    if (ArmyCount(I) <= ACHIEVEMENTS_2ND_CHANCE)
    and (not SecondChance.Get[I])
    and (States.PlayerEnabled(I)) then
    begin
      Actions.ShowMsgFormatted(I, '<$33>' + ' <$144>' + ': <$169>' + ' <$34>' + ' <$191>', [ACHIEVEMENTS_2ND_CHANCE_BOWS, ACHIEVEMENTS_2ND_CHANCE_AXES]);
      if States.PlayerEnabled(I) then
      begin
        Actions.GiveGroup(I, 17, Players[I].SpawnX[1], Players[I].SpawnY[1], Players[I].Direction, ACHIEVEMENTS_2ND_CHANCE_BOWS, 3);
        Actions.GiveGroup(I, 15, Players[I].SpawnX[2], Players[I].SpawnY[2], Players[I].Direction, ACHIEVEMENTS_2ND_CHANCE_AXES, 3);
      end;

      if SecondChance.GetBy = '' then
        SecondChance.GetBy := SecondChance.GetBy + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]'                              //Add name of the player who got the achievement
      else
        SecondChance.GetBy := SecondChance.GetBy + ', ' + '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]';                      //Add name of the player who got the achievement and separator , between names

      SecondChance.Get[I] := True;
      Exit;
    end;
end;


//Achievements Points


procedure GetAddScore;
begin
  for I := 0 to 3 do
  begin

//Second Chance

    if (SecondChance.Get[I])
    and (Mission.AddAchievementScore[I][0]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_2ND_CHANCE_SCORE;
      Mission.AddAchievementScore[I][0] := False;
      Exit;
    end;

//Novice Scout

    if (NoviceScout.Get)
    and (Mission.AddAchievementScore[I][1]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][1] := False;
      Exit;
    end;

//PRO Scout

    if (ProScout.Get)
    and (Mission.AddAchievementScore[I][2]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][2] := False;
    end;

//Counterintellgence

    if (Counterintelligence.Get)
    and (Mission.AddAchievementScore[I][3]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][3] := False;
      Exit;
    end;

//Race against the clock

    if (Race.Get)
    and (Mission.AddAchievementScore[I][4]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][4] := False;
      Exit;
    end;

//Pirates

    if (Pirate.Get)
    and (Mission.AddAchievementScore[I][5]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][5] := False;
      Exit;
    end;

//Meat Grinder

    if (MeatGrinder.Get[I])
    and (Mission.AddAchievementScore[I][6]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][6] := False;
      Exit;
    end;

//Killer

    if (Killer.Get[I])
    and (Mission.AddAchievementScore[I][7]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][7] := False;
      Exit;
    end;

//Iron Man

    if (IronMan.Get[I])
    and (Mission.AddAchievementScore[I][8]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][8] := False;
      Exit;
    end;

//Leather Man

    if (LeatherMan.Get[I])
    and (Mission.AddAchievementScore[I][9]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][9] := False;
      Exit;
    end;

//Barbarian's Boss

    if (BarbsBoss.Get[I])
    and (Mission.AddAchievementScore[I][10]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][10] := False;
      Exit;
    end;

//Rebel

    if (Rebel.Get[I])
    and (Mission.AddAchievementScore[I][11]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][11] := False;
      Exit;
    end;

//Shooter

    if (Shooter.Get[I])
    and (Mission.AddAchievementScore[I][12]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][12] := False;
      Exit;
    end;

//Into Spears!

    if (IntoSpears.Get[I])
    and (Mission.AddAchievementScore[I][13]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][13] := False;
      Exit;
    end;

//Infantryman

    if (Infantryman.Get[I])
    and (Mission.AddAchievementScore[I][14]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][14] := False;
      Exit;
    end;

//Knight

   if (Knight.Get[I])
   and (Mission.AddAchievementScore[I][15]) then
   begin
     Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
     Mission.AddAchievementScore[I][15] := False;
     Exit;
   end;

//Hoooorses

    if (Horses.Get[I])
    and (Mission.AddAchievementScore[I][16]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][16] := False;
      Exit;
    end;

//301st Spartan

    if (Spartan.Get[I])
    and (Mission.AddAchievementScore[I][17]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][17] := False;
      Exit;
    end;

//Demolisher

    if (Demolisher.Get[I])
    and (Mission.AddAchievementScore[I][18]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_SCORE;
      Mission.AddAchievementScore[I][18] := False;
      Exit;
    end;

//Variety

    if (Variety.Get[I])
    and (Mission.AddAchievementScore[I][19]) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + ACHIEVEMENTS_VARIETY_SCORE;
      Mission.AddAchievementScore[I][19] := False;
      Exit;
    end;
  end;
end;


//Variety indexes


procedure GetVarietyIndexes;
begin
  for I := 0 to 3 do
  for N := 0 to 8 do
  begin
    if UnitsCount(I, N + 15) >= Variety.NeededCount[I] then      //Index = 1 for certain type if you have at least 10 soldiers of this type
      Variety.VarietyIndex[I][N] := 1
    else
      Variety.VarietyIndex[I][N] := 0;
  end;
end;


//Achievements progress


procedure GetAchievementsProgress;
begin
  for I := 0 to 3 do
  begin

//Meat Grinder

    if not MeatGrinder.Get[I] then
      MeatGrinder.Progress[I] := '[' + IntToStr(MeatGrinder.FactCount[I]) + '/' + IntToStr(ACHIEVEMENTS_MEAT_GRINDER) + ']: '
    else
      MeatGrinder.Progress[I] := ': ';

//Killer

    if not Killer.Get[I] then
      Killer.Progress[I] := '[' + IntToStr(Killer.FactCount[I]) + '/' + IntToStr(ACHIEVEMENTS_KILLER) + ']: '
    else
      Killer.Progress[I] := ': ';

//Demolisher

    if not Demolisher.Get[I] then
      Demolisher.Progress[I] := '[' + IntToStr(Demolisher.FactCount[I]) + '/' + IntToStr(ACHIEVEMENTS_DEMOLISHER) + ']: '
    else
      Demolisher.Progress[I] := ': ';

//Knight

    if not Knight.Get[I] then
      Knight.Progress[I] := '[' + IntToStr(UnitsCount(I, 22)) + '/' + IntToStr(Knight.NeededCount[I]) + ']: '
    else
      Knight.Progress[I] := ': ';

//Iron Man

    if not IronMan.Get[I] then
      IronMan.Progress[I] :='[' + IntToStr((UnitsCount(I, 16)
      + UnitsCount(I, 18) + UnitsCount(I, 20)
      + UnitsCount(I, 22))) + '/' + IntToStr(IronMan.NeededCount[I]) + ']: '
    else
      IronMan.Progress[I] := ': ';

//Barbarian's Boss

    if not BarbsBoss.Get[I] then
      BarbsBoss.Progress[I] := '[' + IntToStr(UnitsCount(I, 23)) + '/' + IntToStr(BarbsBoss.NeededCount[I]) + ']: '
    else
      BarbsBoss.Progress[I] := ': ';

//Leather Man

    if not LeatherMan.Get[I] then
      LeatherMan.Progress[I] :='[' + IntToStr((UnitsCount(I, 15)
      + UnitsCount(I, 17) + UnitsCount(I, 19)
      + UnitsCount(I, 21))) + '/' + IntToStr(LeatherMan.NeededCount[I]) + ']: '
    else
      LeatherMan.Progress[I] := ': ';

//Variety

    if not Variety.Get[I] then
      Variety.Progress[I] := '[' + IntToStr(Variety.VarietyIndex[I][0]
      + Variety.VarietyIndex[I][1] + Variety.VarietyIndex[I][2]
      + Variety.VarietyIndex[I][3] + Variety.VarietyIndex[I][4]
      + Variety.VarietyIndex[I][5] + Variety.VarietyIndex[I][6]
      + Variety.VarietyIndex[I][7] + Variety.VarietyIndex[I][8]) + '/' + IntToStr(ACHIEVEMENTS_VARIETY_TYPES) + ']: '
    else
      Variety.Progress[I] := ': ';

//Hoooorses

    if not Horses.Get[I] then
      Horses.Progress[I] :='[' + IntToStr((UnitsCount(I, 21)
      + UnitsCount(I, 22))) + '/' + IntToStr(Horses.NeededCount[I]) + ']: '
    else
      Horses.Progress[I] := ': ';

//Shooter

    if not Shooter.Get[I] then
      Shooter.Progress[I] :='[' + IntToStr((UnitsCount(I, 17)
      + UnitsCount(I, 18))) + '/' + IntToStr(Shooter.NeededCount[I]) + ']: '
    else
      Shooter.Progress[I] := ': ';

//Into Spears!

    if not IntoSpears.Get[I] then
      IntoSpears.Progress[I] :='[' + IntToStr((UnitsCount(I, 19)
      + UnitsCount(I, 20))) + '/' + IntToStr(IntoSpears.NeededCount[I]) + ']: '
    else
      IntoSpears.Progress[I] := ': ';

//Infantryman

    if not Infantryman.Get[I] then
      Infantryman.Progress[I] :='[' + IntToStr((UnitsCount(I, 15)
      + UnitsCount(I, 16))) + '/' + IntToStr(Infantryman.NeededCount[I]) + ']: '
    else
      Infantryman.Progress[I] := ': ';

//Rebel

    if not Rebel.Get[I] then
      Rebel.Progress[I] :='[' + IntToStr((UnitsCount(I, 14)
      + UnitsCount(I, 24) + UnitsCount(I, 25)
      + UnitsCount(I, 27))) + '/' + IntToStr(ACHIEVEMENTS_REBEL) + ']: '
    else
      Rebel.Progress[I] := ': ';

//301st Spartan

    if not Spartan.Get[I] then
      Spartan.Progress[I] :='[' + IntToStr(ArmyCount(I))
      + '/' + IntToStr(ACHIEVEMENTS_SPARTAN) + ']: '
    else
      Spartan.Progress[I] := ': ';

//Second Chance

    if not SecondChance.Get[I] then
      SecondChance.Progress[I] :='[' + IntToStr(ArmyCount(I))
      + '/' + IntToStr(ACHIEVEMENTS_2ND_CHANCE) + ']: '
    else
      SecondChance.Progress[I] := ': ';

  end;
end;


//Achievements text for team achievements and the whole achievements text


procedure GetAchievementsText;
begin

  if not NoviceScout.Get then
    NoviceScout.GetBy := ''                                                                             //Team hasn't got this achievement yet, no player names
  else
    NoviceScout.GetBy := Mission.Team;                                                                  //All team members

  if not ProScout.Get then
    ProScout.GetBy := ''                                                                                //Team hasn't got this achievement yet, no player names
  else
    ProScout.GetBy := Mission.Team;                                                                     //All team members

  if not Counterintelligence.Get then
    Counterintelligence.GetBy := ''                                                                     //Team hasn't got this achievement yet, no player names
  else
    Counterintelligence.GetBy := Mission.Team;                                                          //All team members

  if not Race.Get then
    Race.GetBy := ''                                                                                    //Team hasn't got this achievement yet, no player names
  else
    Race.GetBy := Mission.Team;                                                                         //All team members

  if not Pirate.Get then
    Pirate.GetBy := ''                                                                                  //Team hasn't got this achievement yet, no player names
  else
    Pirate.GetBy := Mission.Team;                                                                       //All team members

  for I := 0 to 3 do
    Players[I].AchievementsText := '|<$20>|' + '<$21>|' + '|<$125>: ' + NoviceScout.GetBy               //The whole achievements text
    + '|<$126>: ' + ProScout.GetBy + '|<$127>: ' + Counterintelligence.GetBy + '|<$141>: '
    + Pirate.GetBy +'|<$128>: ' + Race.GetBy + '||<$22>|' + '|<$129>'
    + MeatGrinder.Progress[I] + MeatGrinder.GetBy + '|<$130>' + Killer.Progress[I]
    + Killer.GetBy + '|<$131>' + Demolisher.Progress[I] + Demolisher.GetBy
    + '|<$132>' + Knight.Progress[I] + Knight.GetBy + '|<$133>' + Horses.Progress[I]
    + Horses.GetBy + '|<$134>' + Shooter.Progress[I] + Shooter.GetBy + '|<$135>'
    + IntoSpears.Progress[I] + IntoSpears.GetBy + '|<$136>' + Infantryman.Progress[I]
    + Infantryman.GetBy + '|<$137>' + BarbsBoss.Progress[I] + BarbsBoss.GetBy
    + '|<$142>' + Rebel.Progress[I] + Rebel.GetBy+ '|<$138>' + Variety.Progress[I]
    + Variety.GetBy + '|<$139>' + IronMan.Progress[I] + IronMan.GetBy + '|<$140>'
    + LeatherMan.Progress[I] + LeatherMan.GetBy + '|<$143>' + Spartan.Progress[I] + Spartan.GetBy
    + '|<$144>' + SecondChance.Progress[I] + SecondChance.GetBy;
end;


//Bonus for Pirate achievement


procedure GetPirateBonus;
begin
  if (States.GameTime mod PIRATE_REINF_TIME = 0)
  and (Pirate.Get) then
  begin

    Actions.PlayWAV(-1, 'ARMY', 1);

    for I := 0 to 3 do
      if (States.PlayerEnabled(I))
      and not (States.PlayerDefeated(I)) then
        Actions.ShowMsgGoTo(I, Players[I].ShipX, Players[I].ShipY, '<$25>');

    if (States.PlayerEnabled(0))
    and (not States.PlayerDefeated(0)) then
      Actions.GiveGroup(0, GetTHUnit, 55, 10, 4, 4, 2);

    if (States.PlayerEnabled(1))
    and (not States.PlayerDefeated(1)) then
      Actions.GiveGroup(1, GetTHUnit, 60, 10, 4, 4, 2);

    if (States.PlayerEnabled(2))
    and (not States.PlayerDefeated(2)) then
      Actions.GiveGroup(2, GetTHUnit, 95, 11, 4, 4, 2);

    if (States.PlayerEnabled(3))
    and (not States.PlayerDefeated(3)) then
      Actions.GiveGroup(3, GetTHUnit, 100, 10, 4, 4, 2);

  end;
end;


////////////////////////
//////RANDOM TASKS//////
////////////////////////


//Random additional task


procedure GetRandomTask;
begin
  case States.KaMRandomI(60) of

    0..9: begin
            Mission.RandomTaskID := 1;
            Mission.RandomTask := '<$75>';                                                                             //Destroy all enemy buildings
            Mission.RandomTaskMsg := '<$31> ' + '<$75>';
          end;

    10..19: begin
              Mission.RandomTaskID := 2;
              Mission.RandomTask := '<$76>';                                                                           //Capture the castle without destroying any enemy towers.
              Mission.RandomTaskMsg := '<$31> ' + '<$76>';
            end;

    20..29: begin
              Mission.RandomTaskID := 3;
              Mission.RandomTask := '<$77>';                                                                           //Keep your generals alive
              Mission.RandomTaskMsg := '<$31> ' + '<$77>' + '. <$32>';
            end;

    30..33: begin
              Mission.RandomTaskID := 4;
              Mission.RandomTask := '<$78>';                                                                           //Send 30 mounted units to the castle
              Mission.RandomTaskMsg := '<$31> ' + '<$78>' + '. <$95> ' + '<$96>';
            end;

    34..37: begin
              Mission.RandomTaskID := 5;
              Mission.RandomTask := '<$79>';                                                                           //Send 30 ranged units to the castle
              Mission.RandomTaskMsg := '<$31> ' + '<$79>' + '. <$95> ' + '<$98>';
            end;

    38..41: begin
              Mission.RandomTaskID := 6;
              Mission.RandomTask := '<$80>';                                                                           //Send 15 barbarians to the castle
              Mission.RandomTaskMsg := '<$31> ' + '<$80>';
            end;

    42..45: begin
              Mission.RandomTaskID := 7;
              Mission.RandomTask := '<$81>';                                                                           //Send 30 melee units to the castle
              Mission.RandomTaskMsg := '<$31> ' + '<$81>' + '. <$95> ' + '<$99>';
            end;

    46..53: begin
              Mission.RandomTaskID := 8;
              Mission.RandomTask := '<$82>';                                                                           //Send 30 anti-horse units to the castle
              Mission.RandomTaskMsg := '<$31> ' + '<$82>' + '. <$95> ' + '<$97>';
            end;

    {50..53: begin
              Mission.RandomTaskID := 9;
              Mission.RandomTask := '<$83>';                                                                           //Lose less than 1600 soldiers
              Mission.RandomTaskMsg := '<$31> ' + '<$83>';
            end;}

    54..59: begin
              Mission.RandomTaskID := 10;
              Mission.RandomTask := '<$84>';                                                                           //Kill all enemy citizens
              Mission.RandomTaskMsg := '<$31> ' + '<$84>';
            end;
  end;
end;


//Random tasks: victory conditions


procedure RandomTaskConditions;
var
  X, Y, U: Integer;
begin
  case Mission.RandomTaskID of

    1: begin                                                                                       //Destroy all enemy buildings
         if (DestroyAll.CurrentCount = DestroyAll.NeededCount)
         or (DoubleCheck.NoHousesLeft) then
           Mission.RandomTaskCompleted := True
         else
           Mission.RandomTaskCompleted := False;
       end;

    2: begin                                                                                       //Capture the Castle without destroying any enemy towers
         if (States.StatHouseTypeCount(7, 17) = SaveTowers.NeededCount)
         and (Castle.Time = 0) then
           Mission.RandomTaskCompleted := True
         else
           if States.StatHouseTypeCount(7, 17) < SaveTowers.NeededCount then
           begin
             Mission.RandomTaskCompleted := False;
             Mission.Ended := True;
             for I := 0 to 3 do
               if States.PlayerEnabled(I) then
                 Actions.PlayerDefeat(I);                                                          //Defeat if one of enemy watchtowers is destroyed
           end;
        end;

    3: begin                                                                                                                          //Keep the Generals alive
         if ((States.PlayerEnabled(0)) and ((States.UnitDead(Players[0].GeneralUnit)) or (Players[0].GeneralUnit = -1)))
         or ((States.PlayerEnabled(1)) and ((States.UnitDead(Players[1].GeneralUnit)) or (Players[1].GeneralUnit = -1)))
         or ((States.PlayerEnabled(2)) and ((States.UnitDead(Players[2].GeneralUnit)) or (Players[2].GeneralUnit = -1)))
         or ((States.PlayerEnabled(3)) and ((States.UnitDead(Players[3].GeneralUnit)) or (Players[3].GeneralUnit = -1))) then
         begin
           Mission.RandomTaskCompleted := False;
           Mission.Ended := True;
           for I := 0 to 3 do
             if States.PlayerEnabled(I) then
               Actions.PlayerDefeat(I)                                                                                                //Defeat if one of Generals died
         end
         else
           Mission.RandomTaskCompleted := True;
       end;

     4: begin                                                                                                                         //Send 30 mounted units to the castle
          if States.GameTime mod POSITIONS_CHECK_TIME = 0 then
          begin
            SendMounted.CurrentCount := 0;
            for X := 64 to 69 do
            for Y := 83 to 88 do
            begin
              U := States.UnitAt(X, Y);
              if (U <> -1)
              and (States.UnitOwner(U) >= 0)
              and (States.UnitOwner(U) <= 3) then
                if (States.UnitType(U) = 21)
                or (States.UnitType(U) = 22) then
                  SendMounted.CurrentCount := SendMounted.CurrentCount +1;
            end;
             if SendMounted.CurrentCount >= ADD_TASK_ARMY_COUNT then
               Mission.RandomTaskCompleted := True
             else
               Mission.RandomTaskCompleted := False;
          end;
        end;

    5: begin                                                                                       //Send 30 ranged units to the castle
         if States.GameTime mod POSITIONS_CHECK_TIME = 0 then
         begin
           SendRanged.CurrentCount := 0;
           for X := 64 to 69 do
           for Y := 83 to 88 do
           begin
             U := States.UnitAt(X, Y);
             if (U <> -1)
             and (States.UnitOwner(U) >= 0)
             and (States.UnitOwner(U) <= 3) then
               if (States.UnitType(U) = 17)
               or (States.UnitType(U) = 18) then
                 SendRanged.CurrentCount := SendRanged.CurrentCount +1;
           end;
           if SendRanged.CurrentCount >= ADD_TASK_ARMY_COUNT then
             Mission.RandomTaskCompleted := True
           else
             Mission.RandomTaskCompleted := False;
         end;
       end;

    6: begin                                                                                       //Send 15 Barbarians to the castle
         if States.GameTime mod POSITIONS_CHECK_TIME = 0 then
         begin
           SendBarbs.CurrentCount := 0;
           for X := 64 to 69 do
           for Y := 83 to 88 do
           begin
             U := States.UnitAt(X, Y);
             if (U <> -1)
             and (States.UnitOwner(U) >= 0)
             and (States.UnitOwner(U) <= 3) then
               if (States.UnitType(U) = 23) then
                 SendBarbs.CurrentCount := SendBarbs.CurrentCount +1;
           end;
           if SendBarbs.CurrentCount >= ADD_TASK_BARBS_COUNT then
             Mission.RandomTaskCompleted := True
           else
             Mission.RandomTaskCompleted := False;
         end;
       end;

    7: begin                                                                                       //Send 30 melee units to the castle
         if States.GameTime mod POSITIONS_CHECK_TIME = 0 then
         begin
           SendMelee.CurrentCount := 0;
           for X := 64 to 69 do
           for Y := 83 to 88 do
           begin
             U := States.UnitAt(X, Y);
             if (U <> -1)
             and (States.UnitOwner(U) >= 0)
             and (States.UnitOwner(U) <= 3) then
               if (States.UnitType(U) = 15)
               or (States.UnitType(U) = 16)
               or (States.UnitType(U) = 23) then
                 SendMelee.CurrentCount := SendMelee.CurrentCount +1;
           end;
           if SendMelee.CurrentCount >= ADD_TASK_ARMY_COUNT then
             Mission.RandomTaskCompleted := True
           else
             Mission.RandomTaskCompleted := False;
         end;
       end;

    8: begin                                                                                       //Send 30 anti-horse units to the castle
         if States.GameTime mod POSITIONS_CHECK_TIME = 0 then
         begin
           SendAntihorse.CurrentCount := 0;
           for X := 64 to 69 do
           for Y := 83 to 88 do
           begin
             U := States.UnitAt(X, Y);
             if (U <> -1)
             and (States.UnitOwner(U) >= 0)
             and (States.UnitOwner(U) <= 3) then
               if (States.UnitType(U) = 19)
               or (States.UnitType(U) = 20) then
                 SendAntihorse.CurrentCount := SendAntihorse.CurrentCount +1;
           end;
           if SendAntihorse.CurrentCount >= ADD_TASK_ARMY_COUNT then
             Mission.RandomTaskCompleted := True
           else
             Mission.RandomTaskCompleted := False;
         end;
       end;

    {9: begin
         if LoseNoMore.CurrentCount <= ADD_TASK_LOST_SOLDIERS_COUNT then                           //Lose no more than 1600 soldiers
           Mission.RandomTaskCompleted := True
         else
         begin
           Mission.RandomTaskCompleted := False;
           Mission.Ended := True;
           for I := 0 to 3 do
             Actions.PlayerDefeat(I);
         end;
       end;}

    10: begin
          if (KillAll.CurrentCount = KillAll.NeededCount)
          or (DoubleCheck.NoCitizensLeft) then                                                     //Kill all enemy citizens
            Mission.RandomTaskCompleted := True
          else
            Mission.RandomTaskCompleted := False;
        end;
  end;
end;


//Additional task text


procedure GetAddTaskMsg;
  begin
    if States.GameTime < ADD_TASK_TIME then
      Mission.AddTaskMsg := ''                                                                                         //We get task in 00:00:30
  else
  begin
    case Mission.RandomTaskID of

      1: begin                                                                                                         //Destroy all enemy buildings
           if DestroyAll.CurrentCount < DestroyAll.NeededCount then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$' + BuildingsColor + ']'
             + IntToStr(DestroyAll.CurrentCount) + ' <$6> ' + IntToStr(DestroyAll.NeededCount) + '[]'                  //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      2: begin                                                                                                         //Capture the Castle without destroying any enemy towers
           Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask;                                           //Just show the task
         end;

      3: begin                                                                                                         //Keep the Generals alive
           Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask;                                           //Just show the task
         end;

      4: begin                                                                                                         //Send 30 mounted units
           if SendMounted.CurrentCount < ADD_TASK_ARMY_COUNT then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$' + MountedColor + ']'
             + IntToStr(SendMounted.CurrentCount) + ' <$6> ' + IntToStr(ADD_TASK_ARMY_COUNT) + '[]'                    //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      5: begin                                                                                                         //Send 30 ranged units
           if SendRanged.CurrentCount < ADD_TASK_ARMY_COUNT then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$' + RangedColor + ']'
             + IntToStr(SendRanged.CurrentCount) + ' <$6> ' + IntToStr(ADD_TASK_ARMY_COUNT) + '[]'                     //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      6: begin//Send 15 barbarians
           if SendBarbs.CurrentCount < ADD_TASK_BARBS_COUNT then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$' + BarbsColor + ']'
             + IntToStr(SendBarbs.CurrentCount) + ' <$6> ' + IntToStr(ADD_TASK_BARBS_COUNT) + '[]'                     //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      7: begin                                                                                                         //Send 30 melee units
           if SendMelee.CurrentCount < ADD_TASK_ARMY_COUNT then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$' + MeleeColor + ']'
             + IntToStr(SendMelee.CurrentCount) + ' <$6> ' + IntToStr(ADD_TASK_ARMY_COUNT) + '[]'                      //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      8: begin                                                                                                         //Send 30 anti-horse units
           if SendAntihorse.CurrentCount < ADD_TASK_ARMY_COUNT then
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' +'[$' + AntiHorseColor + ']'
             + IntToStr(SendAntihorse.CurrentCount) + ' <$6> ' + IntToStr(ADD_TASK_ARMY_COUNT) + '[]'                  //In progress...
           else
             Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';    //Task completed
         end;

      {9: begin                                                                                                        //disabled, needs balance tests ;D//Lose less than 1600 soldiers
            if LoseNoMore.CurrentCount <= ADD_TASK_LOST_SOLDIERS_COUNT then
              Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' +'[$' + LostSoldiersColor + ']' + IntToStr(LoseNoMore.CurrentCount)
              + ' <$14> ' + IntToStr(ADD_TASK_LOST_SOLDIERS_COUNT) + '[]';                                             //Show the task and number of lost soldiers
         end;}

      10: begin                                                                                                        //Kill all enemy citizens
            if KillAll.CurrentCount < KillAll.NeededCount then
              Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' +'[$' + CitizensColor + ']'
              + IntToStr(KillAll.CurrentCount) + ' <$6> ' + IntToStr(KillAll.NeededCount) + '[]'                       //In progress...
            else
              Mission.AddTaskMsg := Mission.AddTaskHeader + Mission.RandomTask + ': ' + '[$00FF00]' + '<$5>' + '[]';   //Task completed
          end;
    end;
  end;
end;


///////////////////////////////
//////BONUSES FOR PLAYERS//////
///////////////////////////////


//Small random reinforcement for human players every 7,5 minutes


procedure GetRandomReinforcement;
begin

  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and not (States.PlayerDefeated(I)) then
      Actions.ShowMsgGoTo(I, Players[I].StartX, Players[I].StartY, '<$26>');

  if States.GameTime <> GET_RANGED_TIME then
  begin
    Mission.ReinforcementTime := REINFORCEMENT_TIME;
    Actions.PlayWAV(-1, 'ARMY', 1);

    if (States.PlayerEnabled(0))
    and not (States.PlayerDefeated(0)) then
    begin
      Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 16, 142, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 11, 148, 2, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 16, 154, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);

      if Players[0].IsAlone then
      begin
        Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 16, 148, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 11, 142, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 11, 154, 2, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      end;
    end;

    if (States.PlayerEnabled(1))
    and not (States.PlayerDefeated(1)) then
    begin
      Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 16, 148, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 11, 142, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 11, 154, 2, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);

      if Players[1].IsAlone then
      begin
        Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 16, 142, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 11, 148, 2, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 16, 154, 2, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      end;
    end;

    if (States.PlayerEnabled(2))
    and not (States.PlayerDefeated(2)) then
    begin
      Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 142, 140, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 142, 152, 6, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 147, 146, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);

      if Players[2].IsAlone then
      begin
        Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 142, 146, 6, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 147, 141, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 147, 153, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      end;
    end;

    if (States.PlayerEnabled(3))
    and not (States.PlayerDefeated(3)) then
    begin
      Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 142, 146, 6, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 147, 141, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 147, 153, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);

      if Players[3].IsAlone then
      begin
        Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 142, 140, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN + 1, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 142, 152, 6, States.KaMRandomI(4) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
        Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 147, 146, 6, States.KaMRandomI(3) + REINFORCEMENT_MIN, States.KaMRandomI(2) + 3);
      end;
    end;
  end;
end;


//Useful ranged for all players in 45 minutes


procedure GiveRanged;
begin
  Mission.ReinforcementTime := REINFORCEMENT_TIME;
  Actions.PlayWAV(-1, 'ARMY', 1);

  if (States.PlayerEnabled(0))
  and not (States.PlayerDefeated(0)) then
  begin
    Actions.GiveGroup(0, States.KaMRandomI(2) + 17, 16, 143, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    Actions.GiveGroup(0, States.KaMRandomI(2) + 17, 10, 150, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);

    if Players[0].IsAlone then
    begin
      Actions.GiveGroup(0, States.KaMRandomI(2) + 17, 11, 144, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(0, States.KaMRandomI(2) + 17, 15, 150, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    end;
  end;

  if (States.PlayerEnabled(1))
  and not (States.PlayerDefeated(1)) then
  begin
    Actions.GiveGroup(1, States.KaMRandomI(2) + 17, 11, 144, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    Actions.GiveGroup(1, States.KaMRandomI(2) + 17, 15, 150, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);

    if Players[1].IsAlone then
    begin
      Actions.GiveGroup(1, States.KaMRandomI(2) + 17, 16, 143, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(1, States.KaMRandomI(2) + 17, 10, 150, 2, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    end;
  end;

  if (States.PlayerEnabled(2))
  and not (States.PlayerDefeated(2)) then
  begin
    Actions.GiveGroup(2, States.KaMRandomI(2) + 17, 142, 142, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    Actions.GiveGroup(2, States.KaMRandomI(2) + 17, 149, 149, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);

    if Players[2].IsAlone then
    begin
      Actions.GiveGroup(2, States.KaMRandomI(2) + 17, 147, 143, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(2, States.KaMRandomI(2) + 17, 143, 148, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    end;
  end;

  if (States.PlayerEnabled(3))
  and not (States.PlayerDefeated(3)) then
  begin
    Actions.GiveGroup(3, States.KaMRandomI(2) + 17, 147, 143, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    Actions.GiveGroup(3, States.KaMRandomI(2) + 17, 143, 148, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);

    if Players[3].IsAlone then
    begin
      Actions.GiveGroup(3, States.KaMRandomI(2) + 17, 142, 142, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
      Actions.GiveGroup(3, States.KaMRandomI(2) + 17, 149, 149, 6, States.KaMRandomI(4) + REINFORCEMENT_RANGED_MIN, States.KaMRandomI(2) + 3);
    end;
  end;
end;


//Automatically feed all units every 15 minutes 


procedure AutoFeed;
var
  K: Integer;
  UnitsToFeed: array of Integer;
begin
  for I := 0 to 7 do
  begin
    if States.PlayerEnabled(I) then
      UnitsToFeed := States.PlayerGetAllUnits(I);
    for K := 0 to Length(UnitsToFeed) - 1 do
      Actions.UnitHungerSet(UnitsToFeed[K], States.UnitMaxHunger);
  end;
end;


//Check team score


procedure GetTeamScore;
begin
  Mission.FactTeamScore := Players[0].FactScore + Players[1].FactScore + Players[2].FactScore + Players[3].FactScore;
  Mission.PossibleTeamScore := Players[0].CurrentScore + Players[1].CurrentScore + Players[2].CurrentScore + Players[3].CurrentScore;
end;


//Freeze time


procedure Freeze;
begin
  if TimeFreeze.Time > 0 then
  begin
    TimeFreeze.Time := TimeFreeze.Time - 1;
    Mission.Time := Mission.Time + 1;
  end;
end;


//Invert time


procedure InvertTime;
begin
  if TimeInvert.Time > 0 then
  begin
    TimeInvert.Time := TimeInvert.Time - 1;
    Mission.Time := Mission.Time + 2;
  end;
end;


//Stop freeze time


procedure StopFreeze;
begin
  if TimeFreeze.Time <= 0 then
    TimeFreeze.Stop := True;
end;


//Stop invert time


procedure StopInvert;
begin
  if TimeInvert.Time <= 0 then
    TimeInvert.Stop := True;
end;


//Teleport bonus message time


procedure GetTeleportMsgTime;
begin
  if ResetTeleport.Time > 0 then
    ResetTeleport.Time := ResetTeleport.Time - 1;
end;


//Extra bonus message time


procedure GetExrtaMsgTime;
begin
  if ExtraGroup.Time > 0 then
    ExtraGroup.Time := ExtraGroup.Time - 1;
end;
 

//Report about Invert bonus


procedure InvertReport;
begin
  if not TimeInvert.GetMsg then
  begin
    Actions.ShowMsgFormatted(-1, '<$35>' + ' <$34>' + ' <$202>', ['INVERT', BONUS_INVERT_POINTS]);
    Actions.PlayWAV(-1, 'INVERT', 1);
    TimeInvert.GetMsg := True;
  end;
end;


//Report about Freeze bonus


procedure FreezeReport;
begin
  if not TimeFreeze.GetMsg then
  begin
    Actions.ShowMsgFormatted(-1, '<$35>' + ' <$34>' + ' <$203>', ['FREEZE', BONUS_FREEZE_POINTS]);
    Actions.PlayWAV(-1, 'FREEZE', 1);
    TimeFreeze.GetMsg := True;
  end;
end;


//Bonuses conditions


procedure GetBonusesConditions;
begin

//EXTRA

  if (Mission.FactTeamScore >= BONUS_EXTRA_POINTS)
  and (not ExtraGroup.Get) then
  begin

    if States.PlayerEnabled(0) then
      Actions.GiveGroup(0, States.KaMRandomI(9) + 15, 16, 142, 2, BONUS_EXTRA_TROOP_COUNT, 5);

    if States.PlayerEnabled(1) then
      Actions.GiveGroup(1, States.KaMRandomI(9) + 15, 16, 148, 2, BONUS_EXTRA_TROOP_COUNT, 5);

    if States.PlayerEnabled(2) then
      Actions.GiveGroup(2, States.KaMRandomI(9) + 15, 142, 142, 6, BONUS_EXTRA_TROOP_COUNT, 5);

    if States.PlayerEnabled(3) then
      Actions.GiveGroup(3, States.KaMRandomI(9) + 15, 148, 142, 6, BONUS_EXTRA_TROOP_COUNT, 5);

    Actions.ShowMsgFormatted(-1, '<$35>' + ' <$34>' + ' <$200>', ['EXTRA', BONUS_EXTRA_POINTS]);
    Actions.PlayWAV(-1, 'ARMY', 1);
    ExtraGroup.Get := True;
  end;

//TELEPORT

  if (Mission.FactTeamScore >= BONUS_TELEPORT_POINTS)
  and (not ResetTeleport.Get) then
  begin
    Teleport.Counter := TELEPORTS_MAX;
    Actions.ShowMsgFormatted(-1, '<$35>' + ' <$34>' + ' <$201>', ['TELEPORT', BONUS_TELEPORT_POINTS]);
    Actions.PlayWAV(-1, 'TELEPORT', 1);
    ResetTeleport.Get := True;
  end;

//INVERT

  if not TimeInvert.Get then
    if (Mission.FactTeamScore >= BONUS_INVERT_POINTS)
    and (not TimeInvert.Stop) then
    begin
      InvertTime;
      StopInvert;
      InvertReport;
      if TimeInvert.Stop then
        TimeInvert.Get := True;
    end;

//FREEZE

  if not TimeFreeze.Get then
    if (Mission.FactTeamScore >= BONUS_FREEZE_POINTS)
    and (not TimeFreeze.Stop) then
    begin
      Freeze;
      StopFreeze;
      FreezeReport;
      if TimeFreeze.Stop then
        TimeFreeze.Get := True;
    end;
end;


//Bonuses text


procedure GetBonusesText;
begin
  if (not ExtraGroup.Get)
  or (ExtraGroup.Time <= 0) then
    ExtraGroup.Text := ''
  else
  begin
    if ExtraGroup.Get then
      if States.GameTime mod 10 < 5 then
        ExtraGroup.Text := '||[$00FF00]EXTRA![]'
      else
      if States.GameTime mod 10 > 5 then
        ExtraGroup.Text := '';
  end;

  if (not ResetTeleport.Get)
  or (ResetTeleport.Time <= 0) then
    ResetTeleport.Text := ''
  else
  begin
    if ResetTeleport.Get then
      if States.GameTime mod 10 < 5 then
        ResetTeleport.Text := '||[$00FF00]TELEPORT![]'
      else
      if States.GameTime mod 10 > 5 then
        ResetTeleport.Text := '';
  end;

  if (TimeInvert.Stop)
  or (TimeInvert.Time <= 0) then
    TimeInvert.Text := ''
  else
  begin
    if (TimeInvert.Time > 0)
    and (TimeInvert.GetMsg) then
      if States.GameTime mod 10 < 5 then
        TimeInvert.Text := '||[$00FF00]INVERT![]'
      else
      if States.GameTime mod 10 > 5 then
        TimeInvert.Text := '';
  end;

  if (TimeFreeze.Stop)
  or (TimeFreeze.Time <= 0) then
    TimeFreeze.Text := ''
  else
  begin
    if (TimeFreeze.Time > 0)
    and (TimeFreeze.GetMsg) then
      if States.GameTime mod 10 < 5 then
        TimeFreeze.Text := '||[$00FF00]FREEZE![]'
      else
      if States.GameTime mod 10 > 5 then
        TimeFreeze.Text := '';
  end;
end;


//Function to make groups link to closest group


function FindClosestGroup(aPlayer, aX, aY, aType, aRadius: Integer): Integer; 
var 
  Groups: array of Integer;
  G, BestDistanceSqr, ThisDistanceSqr, DX, DY: Integer;
begin
  Result := -1;
  Groups := States.PlayerGetAllGroups(aPlayer);
  for I := 0 to Length(Groups) - 1 do
  begin
    G := Groups[I];
    DX := aX - States.UnitPositionX(States.GroupMember(G, 0));
    DY := aY - States.UnitPositionY(States.GroupMember(G, 0));
    ThisDistanceSqr := (DX * DX) + (DY * DY);
    if ((Abs(DX) < aRadius)
    and (Abs(DY) < aRadius))
    and ((Result = -1)
    or (ThisDistanceSqr< BestDistanceSqr))
    and (States.GroupType(G) = aType) then
    begin
      BestDistanceSqr := ThisDistanceSqr;
      Result := Groups[I];
    end;
  end;
end;


//Magic! Teleport ;D


procedure GetTeleport;
begin

//For left side

  Teleport.GroupLeft := States.GroupAt(4, 133);
  if (Teleport.GroupLeft <> -1)
  and (Teleport.GroupLeft <> 0)
  and (States.GroupOwner(Teleport.GroupLeft) <= 3)
  and (States.GroupOwner(Teleport.GroupLeft) >= 0) then
  begin
    Teleport.TypeLeft := States.UnitType(States.UnitAt(4, 133));
    Teleport.OwnerLeft := States.GroupOwner(Teleport.GroupLeft);
    Teleport.GroupTypeLeft := States.GroupType(Teleport.GroupLeft);
    Actions.UnitKill(States.UnitAt(4, 133), True);
    Teleport.UnitLeft := Actions.GiveGroup(Teleport.OwnerLeft, Teleport.TypeLeft, 148, 130, 6, 1, 1);
    Teleport.NewGroupLeft := FindClosestGroup(Teleport.OwnerLeft, 148, 130, Teleport.GroupTypeLeft, TELEPORTS_LINK_RADIUS);
    Actions.GroupOrderLink(Teleport.UnitLeft, Teleport.NewGroupLeft);
    Actions.GroupSetFormation(Teleport.NewGroupLeft, 1 + Round(sqrt(States.GroupMemberCount(Teleport.NewGroupLeft))));
  end;

//For right side

  Teleport.GroupRight := States.GroupAt(154, 133);
  if (Teleport.GroupRight <> -1)
  and (Teleport.GroupRight <> 0)
  and (States.GroupOwner(Teleport.GroupRight) <= 3)
  and (States.GroupOwner(Teleport.GroupRight) >= 0) then
  begin
    Teleport.TypeRight := States.UnitType(States.UnitAt(154, 133));
    Teleport.OwnerRight := States.GroupOwner(Teleport.GroupRight);
    Teleport.GroupTypeRight := States.GroupType(Teleport.GroupRight);
    Actions.UnitKill(States.UnitAt(154, 133), True);
    Teleport.UnitRight := Actions.GiveGroup(Teleport.OwnerRight, Teleport.TypeRight, 9, 131, 2, 1, 1);
    Teleport.NewGroupRight := FindClosestGroup(Teleport.OwnerRight, 9, 131, Teleport.GroupTypeRight, TELEPORTS_LINK_RADIUS);
    Actions.GroupOrderLink(Teleport.UnitRight, Teleport.NewGroupRight);
    Actions.GroupSetFormation(Teleport.NewGroupRight, 1 + Round(sqrt(States.GroupMemberCount(Teleport.NewGroupRight))));
  end;
end;


function TeleportFound: Boolean;
begin
  Result := (AreaRevealed(0, 10, 128)
  or (AreaRevealed(1, 10, 128))
  or (AreaRevealed(2, 150, 128))
  or (AreaRevealed(3, 150, 128)));
end;


//Report about teleport


procedure TeleportReport;
begin
  for I := 0 to 1 do
  if States.PlayerEnabled(I) then
  begin
    Actions.ShowMsgGoTo(I, 4, 133, '<$29>');
    Actions.FogRevealCircle(I, 4, 133, 4);
  end;

  for I := 2 to 3 do
  if States.PlayerEnabled(I) then
  begin
    Actions.ShowMsgGoTo(I, 154, 133, '<$29>');
    Actions.FogRevealCircle(I, 154, 133, 4);
  end;

  Mission.TeleportMsg := True;

end;


///////////////////////////
//////CHECK POSITIONS//////
///////////////////////////


///Check: have we visited and captured position?///


//For western outpost


procedure CheckWestern;
var 
  GW,                                            //ID of group that holds the position
  XW, YW: Integer;                               //Coordinates of the position
begin
  for XW := 4 to 6 do                            //Check if our troops hold position
  for YW := 112 to 114 do
  begin
    GW := States.GroupAt(XW, YW);
    if (GW <> - 1)
    and (States.GroupOwner(GW) <=3)
    and (States.GroupOwner(GW) <> -1)
    and (WesternOutpost.Time > 0) then
    begin
      WesternOutpost.Time := WesternOutpost.Time - 1;
      WesternOutpost.Captured := True;
      WesternOutpost.Visited := True;
      Exit;
    end
    else
      WesternOutpost.Captured := False;          //Control over position is lost
  end;
end;


//For northern outpost


procedure CheckNorthern;
var 
  GN,                                            //ID of group that holds the position
  XN, YN: Integer;                               //Coordinates of the position
begin
  for XN := 79 to 81 do                          //Check if our troops hold position
  for YN := 5 to 7 do
  begin
    GN := States.GroupAt(XN, YN);
    if (GN <> - 1)
    and (States.GroupOwner(GN) <=3)
    and (States.GroupOwner(GN) <> -1)
    and (NorthernOutpost.Time > 0) then
    begin
      NorthernOutpost.Time := NorthernOutpost.Time - 1;
      NorthernOutpost.Captured := True;
      NorthernOutpost.Visited := True;
      Exit;
    end
    else
      NorthernOutpost.Captured := False;         //Control over position is lost
  end;
end;


//For eastern outpost


procedure CheckEastern;
var 
  GE,                                            //ID of group that holds the position
  XE, YE: Integer;                               //Coordinates of the position
begin
  for XE := 154 to 156 do                        //Check if our troops hold position
  for YE := 112 to 114 do
  begin
    GE := States.GroupAt(XE, YE);
    if (GE <> - 1)
    and (States.GroupOwner(GE) <=3)
    and (States.GroupOwner(GE) <> -1)
    and (EasternOutpost.Time > 0) then
    begin
      EasternOutpost.Time := EasternOutpost.Time - 1;
      EasternOutpost.Captured := True;
      EasternOutpost.Visited := True;
      Exit;
    end
    else
      EasternOutpost.Captured := False;          //Control over position is lost
  end;
end;


//For southern outpost


procedure CheckSouthern;
var 
  GS,                                            //ID of group that holds the position
  XS, YS: Integer;                               //Coordinates of the position
begin
  for XS := 79 to 81 do                          //Check if our troops hold position
  for YS := 153 to 155 do
  begin
    GS := States.GroupAt(XS, YS);
    if (GS <> - 1)
    and (States.GroupOwner(GS) <=3)
    and (States.GroupOwner(GS) <> -1)
    and (SouthernOutpost.Time > 0) then
    begin
      SouthernOutpost.Time := SouthernOutpost.Time - 1;
      SouthernOutpost.Captured := True;
      SouthernOutpost.Visited := True;
      Exit;
    end
    else
      SouthernOutpost.Captured := False;         //Control over position is lost
  end;
end;


//For The Castle


procedure CheckCastle;
var 
  GC,                                            //ID of group that holds the position
  XC, YC: Integer;                               //Coordinates of the position
begin
  for XC := 64 to 69 do                          //Check if our troops hold position
  for YC := 83 to 88 do
  begin
    GC := States.GroupAt(XC, YC);
    if (GC <> - 1)
    and (States.GroupOwner(GC) <=3)
    and (States.GroupOwner(GC) <> -1)
    and (Castle.Time > 0) then
    begin
      if not (DestroyMilitary.CurrentCount = DestroyMilitary.NeededCount) then
        Castle.Time := POSITION_VISITED_TIME
      else
      begin
        Castle.Time := Castle.Time - 1;
        Castle.Captured := True;
        Castle.Visited := True;
        Exit;
      end;
    end
    else
      Castle.Captured := False;                  //Control over position is lost
  end;
end;


//Points for capturing positions


procedure GetPointsForCapturing;
begin
  for I := 0 to 3 do
  if States.PlayerEnabled(I) then
  begin

//For Eastern Outpost

    if (EasternOutpost.Captured)
    and (not EasternOutpost.PointsGiven) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + CAPTURE_OUTPOST_SCORE;
      EasternOutpost.PointsGiven := True;
    end;

//For Western Outpost

    if (WesternOutpost.Captured)
    and (not WesternOutpost.PointsGiven) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + CAPTURE_OUTPOST_SCORE;
      WesternOutpost.PointsGiven := True;
    end;

//For Southern Outpost

    if (SouthernOutpost.Captured)
    and (not SouthernOutpost.PointsGiven) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + CAPTURE_OUTPOST_SCORE;
      SouthernOutpost.PointsGiven := True;
    end;

//For Northern Outpost

    if (NorthernOutpost.Captured)
    and (not NorthernOutpost.PointsGiven) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + CAPTURE_OUTPOST_SCORE;
      NorthernOutpost.PointsGiven := True;
    end;

//For The Castle

    if (Castle.Captured)
    and (not Castle.PointsGiven) then
    begin
      Players[I].CurrentScore := Players[I].CurrentScore + CAPTURE_CASTLE_SCORE;
      Castle.PointsGiven := True;
    end;
  end;
end;


//Play sound when position is captured


procedure PlayCaptureSound;
begin

//For Eastern Outpost

  if (EasternOutpost.Time = 0)
  and (not EasternOutpost.SoundPlayed) then
  begin
    Actions.PlayWAV(-1, 'OUTPOSTDONE', 1);
    EasternOutpost.SoundPlayed := True;
  end;

//For Western Outpost

  if (WesternOutpost.Time = 0)
  and (not WesternOutpost.SoundPlayed) then
  begin
    Actions.PlayWAV(-1, 'OUTPOSTDONE', 1);
    WesternOutpost.SoundPlayed := True;
  end;

//For Southern Outpost

  if (SouthernOutpost.Time = 0)
  and (not SouthernOutpost.SoundPlayed) then
  begin
    Actions.PlayWAV(-1, 'OUTPOSTDONE', 1);
    SouthernOutpost.SoundPlayed := True;
  end;

//For Northern Outpost

  if (NorthernOutpost.Time = 0)
  and (not NorthernOutpost.SoundPlayed) then
  begin
    Actions.PlayWAV(-1, 'OUTPOSTDONE', 1);
    NorthernOutpost.SoundPlayed := True;
  end;

//For The Castle

  if (Castle.Time = 0)
  and (not Castle.SoundPlayed) then
  begin
    Actions.PlayWAV(-1, 'OUTPOSTDONE', 1);
    Castle.SoundPlayed := True;
  end;
end;


//////////////////////////////
//////MISSION CONDITIONS//////
//////////////////////////////


//Victory and defeat conditions


procedure CheckVictoryDefeat;
begin

//Victory if all 11 tasks and additional task are completed in time

  if (WesternOutpost.Time = 0)                                                 //Western outpost is captured
  and (EasternOutpost.Time = 0)                                                //Eastern outpost is captured
  and (SouthernOutpost.Time = 0)                                               //Southern outpost is captured
  and (NorthernOutpost.Time = 0)                                               //Northern outpost is captured
  and (Castle.Time = 0)                                                        //The castle is captured
  and (DestroyIron.CurrentCount = DestroyIron.NeededCount)                     //All iron mines are destroyed
  and (DestroyGold.CurrentCount = DestroyGold.NeededCount)                     //All gold mines are destroyed
  and (DestroyCoal.CurrentCount = DestroyCoal.NeededCount)                     //All coal mines are destroyed
  and (DestroyMilitary.CurrentCount = DestroyMilitary.NeededCount)             //All military buildings and schools are destroyed
  and (DestroyStores.CurrentCount = DestroyStores.NeededCount)                 //All storehouses are destroyed
  and (KillSoldiers.CurrentCount = KillSoldiers.NeededCount)                   //All enemy soldiers are killed
  and (Mission.RandomTaskCompleted) then                                       //Additional task is completed
  begin
    Mission.TasksCompleted := True;
    Mission.Ended := True;
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        Actions.PlayerWin([I], True);
  end;

//Defeat if just one task is not completed in time

  if (Mission.Time = 0)
  and (not Mission.TasksCompleted) then
  begin
    Mission.Ended := True;
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        Actions.PlayerDefeat(I);
  end;
end;


//////////////////////////
//////DEBUG OPTIONS///////
//////////////////////////


//Check victory and log team and time


procedure OnPlayerVictory(aPlayerID: Integer);
begin
  if (aPlayerID >= 0)
  and (aPlayerID <= 3)
  and (DEBUG_MODE)
  and (not Mission.TeamVictoryLogged) then
  begin
    Actions.Log('Team ' + Mission.Team + ' won this mission at ' + IntToStr(States.GameTime) + '-th tick');
    Mission.TeamVictoryLogged := True;
    Exit;
  end;
end;


//Log secret tiles list for debugging


procedure LogTiles;
begin
  for I := 0 to 24 do
    Actions.Log('Define secret tiles: ' + IntToStr(SecretTiles[I].X) + ', ' + InttoStr(SecretTiles[I].Y));
  Exit;
end;


////////////////////
//////ON TICK///////
////////////////////


procedure OnTick;
begin

  if Mission.Ended then      //No need to check smth when the game ended
    Exit;

  GetTimeLeft;
  GetMessages;
  GetText;
  CheckWestern;
  CheckEastern;
  CheckSouthern;
  CheckNorthern;
  CheckCastle;
  ResetWTimer;
  ResetETimer;
  ResetSTimer;
  ResetNTimer;
  ResetCTimer;
  GetSoldiersType;
  GetRandomAttack;
  CheckVictoryDefeat;
  CheckSpotted;
  GetReinforcementTimer
  GetAddTaskMsg;
  GetAchievements;
  GetAchievementsText;
  GetStatistic;
  GetVarietyIndexes;
  GetAchievementsProgress;
  GetPirateBonus;
  GetLTColor;
  GetScoresText;
  GetAddScore;
  GetTeamScore;
  GetBonusesText;
  GetBonusesConditions;
  GetExrtaMsgTime;
  GetTeleportMsgTime;
  GetPenaltyScore;
  GetPointsForCapturing;
  PlayCaptureSound;
  CheckTilesBonus;

  if (States.GameTime mod REINF_FORMATION_TIME = 0)
  and (Mission.Notification) then
    SaveFormation;

  if States.GameTime mod DEFENSE_CHECK_TIME = 0 then
    GetAIDefense(False);

  if States.GameTime mod DEFENSE_CHECK_TIME_RANGED = 0 then
    GetAIDefense(True);

  if States.GameTime > ADD_TASK_TIME then
    RandomTaskConditions;

  if States.GameTime < ADD_TASK_TIME then
    GetRandomTask;

  if Teleport.Counter > 0 then
    GetTeleport;

  if States.GameTime = ADD_TASK_TIME then
    Actions.ShowMsg(-1, Mission.RandomTaskMsg);

  if States.GameTime = 30 then
    Actions.ShowMsg(-1, '<$30>');

  if (TeleportFound)
  and (not Mission.TeleportMsg) then
    TeleportReport;

  if States.GameTime mod PATROLS_TIME = 0 then
    GetPatrol;
 
  if (States.GameTime mod REINFORCEMENT_TIME = 0)
  and (States.GameTime > 0) then
    GetRandomReinforcement;

  if (States.GameTime mod AUTO_FEED_TIME = 0)
  and (States.GameTime > 0) then
    AutoFeed;

  if States.GameTime = AI_EQUIP_START_TIME then
    AIEquipReport;

  if States.GameTime = GET_RANGED_TIME then
    GiveRanged;

  if States.GameTime <= SECRET_TILES_TIME then
    GetTiles;

  if States.GameTime mod TILES_CHECK_TIME = 0 then
    CheckTiles;

  if (States.GameTime = SECRET_TILES_TIME)
  and (DEBUG_MODE) then
    LogTiles;

  if States.GameTime mod DOUBLE_CHECK_TIME = 0 then
    ConditionsDoubleCheck;

end;